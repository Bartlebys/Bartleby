//
//  ActiveDocument
//
//  The is the central piece of the Document oriented architecture.
//  We provide a universal implementation with conditionnal compilation
//
//  The document stores references to Bartleby's style ManagedCollections.
//  This allow to use intensively bindings and distributed data automation.
//  With the mediation of standard Bindings approach with NSArrayControler
//
//  We prefer to centralize the complexity of data handling in the document.
//  Thats why for example we implement projectBindingsArrayController.didSet with an CGD dispatching
//  We could have set the binding programmatically in the WindowController
//  But we consider for clarity that the Storyboarded Bindings Settings should be as exhaustive as possible.
//  And the potential complexity masked.
//
//  Generated by flexions
//

import Foundation

#if os(OSX)
    import AppKit
#else
    import UIKit
#endif

import Foundation
#if !USE_EMBEDDED_MODULES
    import Alamofire
    import ObjectMapper
#endif

extension BartlebyDocument{

#if os(OSX)

    open override func read(from url: URL, ofType typeName: String) throws {

        let fileWrapper = try FileWrapper(url: url, options: FileWrapper.ReadingOptions.immediate)
        if let fileWrappers=fileWrapper.fileWrappers {

            // ##############
            // # Metadata
            // ##############

            if let wrapper=fileWrappers[_metadataFileName] {
                if var metadataData=wrapper.regularFileContents {
                    metadataData = try Bartleby.cryptoDelegate.decryptData(metadataData)
                    let r = try Bartleby.defaultSerializer.deserialize(metadataData)
                    if let metadata=r as? DocumentMetadata {
                        self.metadata = metadata
                        self.metadata.document = self
                    } else {
                        // There is an error
                        self.log("ERROR \(r)", file: #file, function: #function, line: #line)
                        return
                    }
                    let documentUID=self.metadata.rootObjectUID
                    Bartleby.sharedInstance.replaceDocumentUID(Default.NO_UID, by: documentUID)
                    self.metadata.currentUser?.document=self
                }
            } else {
                // ERROR
            }

            // ##############
            // # BSFS DATA
            // ##############

            if let wrapper=fileWrappers[_bsfsDataFileName] {
                if var data=wrapper.regularFileContents {
                    data = try Bartleby.cryptoDelegate.decryptData(data)
                    try self.bsfs.restoreStateFrom(data: data)
                }
            } else {
                // ERROR
            }

            // ##############
            // # Collections
            // ##############

            for metadatum in self.metadata.collectionsMetadata {
                // MONOLITHIC STORAGE
                if metadatum.storage == CollectionMetadatum.Storage.monolithicFileStorage {
                    let names=self._collectionFileNames(metadatum)
                    if let wrapper=fileWrappers[names.crypted] ?? fileWrappers[names.notCrypted] {
                        let filename=wrapper.filename
                        if var collectionData=wrapper.regularFileContents {
                            if let proxy=self.collectionByName(metadatum.collectionName) {
                                if let path=filename {
                                    if let ext=path.components(separatedBy: ".").last {
                                        let pathExtension="."+ext
                                        if  pathExtension == BartlebyDocument.DATA_EXTENSION {
                                            // Use the faster possible approach.
                                            // The resulting data is not a valid String check CryptoDelegate for details.
                                            let collectionString = try Bartleby.cryptoDelegate.decryptStringFromData(collectionData)
                                            collectionData = collectionString.data(using:.utf8) ?? Data()
                                        }
                                    }
                                    let _ = try proxy.updateData(collectionData,provisionChanges: false)
                                }
                            } else {
                                throw DocumentError.attemptToLoadAnNonSupportedCollection(collectionName:metadatum.d_collectionName)
                            }
                        }
                    } else {
                        // ERROR
                    }
                } else {
                    // INCREMENTAL STORAGE CURRENTLY NOT SUPPORTED
                }
            }
            do {
                try self._refreshProxies()
            } catch {
                self.log("Proxies refreshing failure \(error)", file: #file, function: #function, line: #line)
            }
            
           Async.main{
                self.documentDidLoad()
            }
        }

    }

    open override func write(to url: URL, ofType typeName: String) throws {

        self.documentWillSave()
        let fileWrapper=FileWrapper(directoryWithFileWrappers:[:])
        if var fileWrappers=fileWrapper.fileWrappers {

            // ##############
            // # Metadata
            // ##############

            // Try to store a preferred filename
            self.metadata.preferredFileName=self.fileURL?.lastPathComponent
            var metadataData=self.metadata.serialize()

            metadataData = try Bartleby.cryptoDelegate.encryptData(metadataData)

            // Remove the previous metadata
            if let wrapper=fileWrappers[self._metadataFileName] {
                fileWrapper.removeFileWrapper(wrapper)
            }
            let metadataFileWrapper=FileWrapper(regularFileWithContents: metadataData)
            metadataFileWrapper.preferredFilename=self._metadataFileName
            fileWrapper.addFileWrapper(metadataFileWrapper)

            // ##############
            // # BSFS DATA
            // ##############

            if let wrapper=fileWrappers[self._bsfsDataFileName]{
                fileWrapper.removeFileWrapper(wrapper)
            }

            let data = try Bartleby.cryptoDelegate.encryptData(self.bsfs.saveState())
            let bsfsFileWrapper=FileWrapper(regularFileWithContents:data)
            bsfsFileWrapper.preferredFilename=self._bsfsDataFileName
            fileWrapper.addFileWrapper(bsfsFileWrapper)


            // ##############
            // # Collections
            // ##############

            for metadatum: CollectionMetadatum in self.metadata.collectionsMetadata {

                if !metadatum.inMemory {
                    let collectionfileName=self._collectionFileNames(metadatum).crypted
                    // MONOLITHIC STORAGE
                    if metadatum.storage == CollectionMetadatum.Storage.monolithicFileStorage {

                        if let collection = self.collectionByName(metadatum.collectionName) as? CollectibleCollection {

                            // We use multiple files

                            // Use the faster possible approach.
                            // The resulting data is not a valid String check CryptoDelegate for details.
                            let collectionString = collection.serializeToUFf8String()
                            let collectionData = try Bartleby.cryptoDelegate.encryptStringToData(collectionString)
                            
                            // Remove the previous data
                            if let wrapper=fileWrappers[collectionfileName] {
                                fileWrapper.removeFileWrapper(wrapper)
                            }
                            
                            let collectionFileWrapper=FileWrapper(regularFileWithContents: collectionData)
                            collectionFileWrapper.preferredFilename=collectionfileName
                            fileWrapper.addFileWrapper(collectionFileWrapper)
                        } else {
                            // NO COLLECTION
                        }
                    } else {
                        // INCREMENTAL STORAGE CURRENTLY NOT SUPPORTED
                    }
                    
                }
            }
        }

        try fileWrapper.write(to: url, options: FileWrapper.WritingOptions.atomic, originalContentsURL: nil)

    }
#else


    // MARK: iOS UIDocument serialization / deserialization

    // TODO: @bpds(#IOS) UIDocument support

    // SAVE content
    override open func contents(forType typeName: String) throws -> Any {
    return ""
    }

    // READ content
    open override func load(fromContents contents: Any, ofType typeName: String?) throws {

    }
    
#endif

}
