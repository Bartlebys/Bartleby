//
//  RegistryMetadata.swift
//  Bartleby
//
// THIS FILE AS BEEN GENERATED BY BARTLEBYFLEXIONS for b@bartlebys.org
// DO NOT MODIFY THIS FILE YOUR MODIFICATIONS WOULD BE ERASED ON NEXT GENERATION!
//
// Copyright (c) 2016  Bartleby's | https://bartlebys.org  All rights reserved.
//
import Foundation
#if !USE_EMBEDDED_MODULES
import Alamofire
import ObjectMapper
#endif

// MARK: Bartleby's Core: Complete implementation in JRegistryMetadata. All its properties are not supervisable.
@objc(RegistryMetadata) public class RegistryMetadata : JObject{

    // Universal type support
    override public class func typeName() -> String {
        return "RegistryMetadata"
    }

	//The data space UID can be shared between multiple registries.
	dynamic public var spaceUID:String = "\(Default.NO_UID)"
	//The user currently associated to the local instance of the registry
	dynamic public var currentUser:User? {	 
	    didSet { 
	       if currentUser != oldValue {
	            self.provisionChanges(forKey: "currentUser",oldValue: oldValue,newValue: currentUser) 
	       } 
	    }
	}

	//The identification method (By cookie or by Key - kvid)
	public enum IdentificationMethod:String{
		case Key = "Key"
		case Cookie = "Cookie"
	}
	public var identificationMethod:IdentificationMethod = .Key
	//The current kvid identification value (injected in HTTP headers)
	dynamic public var identificationValue:String? {	 
	    didSet { 
	       if identificationValue != oldValue {
	            self.provisionChanges(forKey: "identificationValue",oldValue: oldValue,newValue: identificationValue) 
	       } 
	    }
	}

	//The rootObject UID
	dynamic public var rootObjectUID:String = "\(Default.NO_UID)"{	 
	    didSet { 
	       if rootObjectUID != oldValue {
	            self.provisionChanges(forKey: "rootObjectUID",oldValue: oldValue,newValue: rootObjectUID) 
	       } 
	    }
	}

	//The url of the collaboration server
	dynamic public var collaborationServerURL:NSURL? {	 
	    didSet { 
	       if collaborationServerURL != oldValue {
	            self.provisionChanges(forKey: "collaborationServerURL",oldValue: oldValue,newValue: collaborationServerURL) 
	       } 
	    }
	}

	//A collection of CollectionMetadatum
	dynamic public var collectionsMetadata:[CollectionMetadatum] = [CollectionMetadatum]()  {	 
	    didSet { 
	       if collectionsMetadata != oldValue {
	            self.provisionChanges(forKey: "collectionsMetadata",oldValue: oldValue,newValue: collectionsMetadata)  
	       } 
	    }
	}

	//is the user performing Online
	dynamic public var online:Bool = Bartleby.configuration.ONLINE_BY_DEFAULT  {	 
	    didSet { 
	       if online != oldValue {
	            self.provisionChanges(forKey: "online",oldValue: oldValue,newValue: online)  
	       } 
	    }
	}

	//If set to true any object creation, update, or deletion will be pushed to the server immediately
	dynamic public var pushOnChanges:Bool = true  {	 
	    didSet { 
	       if pushOnChanges != oldValue {
	            self.provisionChanges(forKey: "pushOnChanges",oldValue: oldValue,newValue: pushOnChanges)  
	       } 
	    }
	}

	//The State dictionary to insure registry persistency 
	dynamic public var stateDictionary:[String:AnyObject] = [String:AnyObject]()
	//The collection of serialized Security-Scoped Bookmarks (you should store NSData)
	dynamic public var URLBookmarkData:[String:AnyObject] = [String:AnyObject]()
	//Save the password or not?
	dynamic public var saveThePassword:Bool = Bartleby.configuration.SAVE_PASSWORD_DEFAULT_VALUE  {	 
	    didSet { 
	       if saveThePassword != oldValue {
	            self.provisionChanges(forKey: "saveThePassword",oldValue: oldValue,newValue: saveThePassword)  
	       } 
	    }
	}

	//The preferred filename for this registry/document
	dynamic public var preferredFileName:String? {	 
	    didSet { 
	       if preferredFileName != oldValue {
	            self.provisionChanges(forKey: "preferredFileName",oldValue: oldValue,newValue: preferredFileName) 
	       } 
	    }
	}

	//A collection of trigger Indexes (used to detect data holes)
	dynamic public var triggersIndexes:[Int] = [Int]()  {	 
	    didSet { 
	       if triggersIndexes != oldValue {
	            self.provisionChanges(forKey: "triggersIndexes",oldValue: oldValue,newValue: triggersIndexes)  
	       } 
	    }
	}

	//The persistentcollection of triggers indexes owned by the current user (allows local distinctive analytics even on cloned documents)
	dynamic public var ownedTriggersIndexes:[Int] = [Int]()  {	 
	    didSet { 
	       if ownedTriggersIndexes != oldValue {
	            self.provisionChanges(forKey: "ownedTriggersIndexes",oldValue: oldValue,newValue: ownedTriggersIndexes)  
	       } 
	    }
	}

	//The index of the last trigger that has been integrated
	public var lastIntegratedTriggerIndex:Int = -1  {	 
	    didSet { 
	       if lastIntegratedTriggerIndex != oldValue {
	            self.provisionChanges(forKey: "lastIntegratedTriggerIndex",oldValue: oldValue,newValue: lastIntegratedTriggerIndex)  
	       } 
	    }
	}

	//A collection Triggers that are temporarly stored before data integration
	dynamic public var receivedTriggers:[Trigger] = [Trigger]()  {	 
	    didSet { 
	       if receivedTriggers != oldValue {
	            self.provisionChanges(forKey: "receivedTriggers",oldValue: oldValue,newValue: receivedTriggers)  
	       } 
	    }
	}

	//The serialized version of loaded trigger data that are pending integration
	public var triggeredDataBuffer:NSData? {	 
	    didSet { 
	       if triggeredDataBuffer != oldValue {
	            self.provisionChanges(forKey: "triggeredDataBuffer",oldValue: oldValue,newValue: triggeredDataBuffer) 
	       } 
	    }
	}

	//Do we have operations in progress in the current bunch ?
	dynamic public var bunchInProgress:Bool = false
	//The highest number that we may have counted
	public var totalNumberOfOperations:Int = 0
	//The consolidated progression state of all pending operations
	dynamic public var pendingOperationsProgressionState:Progression?


    // MARK: Mappable

    required public init?(_ map: Map) {
        super.init(map)
    }

    override public func mapping(map: Map) {
        super.mapping(map)
        self.disableSupervisionAndCommit()
		self.spaceUID <- ( map["spaceUID"] )
		self.currentUser <- ( map["currentUser"] )
		self.identificationMethod <- ( map["identificationMethod"] )
		self.identificationValue <- ( map["identificationValue"] )
		self.rootObjectUID <- ( map["rootObjectUID"] )
		self.collaborationServerURL <- ( map["collaborationServerURL"], URLTransform() )
		self.collectionsMetadata <- ( map["collectionsMetadata"] )
		self.online <- ( map["online"] )
		self.pushOnChanges <- ( map["pushOnChanges"] )
		self.stateDictionary <- ( map["stateDictionary"] )
		self.URLBookmarkData <- ( map["URLBookmarkData"] )
		self.saveThePassword <- ( map["saveThePassword"] )
		self.preferredFileName <- ( map["preferredFileName"] )
		self.triggersIndexes <- ( map["triggersIndexes"] )
		self.ownedTriggersIndexes <- ( map["ownedTriggersIndexes"] )
		self.lastIntegratedTriggerIndex <- ( map["lastIntegratedTriggerIndex"] )
		self.receivedTriggers <- ( map["receivedTriggers"] )
		self.triggeredDataBuffer <- ( map["triggeredDataBuffer"], Base64DataTransform() )
        self.enableSuperVisionAndCommit()
    }


    // MARK: NSSecureCoding

    required public init?(coder decoder: NSCoder) {
        super.init(coder: decoder)
        self.disableSupervisionAndCommit()
		self.spaceUID=String(decoder.decodeObjectOfClass(NSString.self, forKey: "spaceUID")! as NSString)
		self.currentUser=decoder.decodeObjectOfClass(User.self, forKey: "currentUser") 
		self.identificationMethod=RegistryMetadata.IdentificationMethod(rawValue:String(decoder.decodeObjectOfClass(NSString.self, forKey: "identificationMethod")! as NSString))! 
		self.identificationValue=String(decoder.decodeObjectOfClass(NSString.self, forKey:"identificationValue") as NSString?)
		self.rootObjectUID=String(decoder.decodeObjectOfClass(NSString.self, forKey: "rootObjectUID")! as NSString)
		self.collaborationServerURL=decoder.decodeObjectOfClass(NSURL.self, forKey:"collaborationServerURL") as NSURL?
		self.collectionsMetadata=decoder.decodeObjectOfClasses(NSSet(array: [NSArray.classForCoder(),CollectionMetadatum.classForCoder()]), forKey: "collectionsMetadata")! as! [CollectionMetadatum]
		self.online=decoder.decodeBoolForKey("online") 
		self.pushOnChanges=decoder.decodeBoolForKey("pushOnChanges") 
		self.stateDictionary=decoder.decodeObjectOfClasses(NSSet(array: [NSDictionary.classForCoder(),NSString.classForCoder(),NSNumber.classForCoder(),NSObject.classForCoder(),NSSet.classForCoder()]), forKey: "stateDictionary")as! [String:AnyObject]
		self.URLBookmarkData=decoder.decodeObjectOfClasses(NSSet(array: [NSDictionary.classForCoder(),NSString.classForCoder(),NSNumber.classForCoder(),NSObject.classForCoder(),NSSet.classForCoder()]), forKey: "URLBookmarkData")as! [String:AnyObject]
		self.saveThePassword=decoder.decodeBoolForKey("saveThePassword") 
		self.preferredFileName=String(decoder.decodeObjectOfClass(NSString.self, forKey:"preferredFileName") as NSString?)
		self.triggersIndexes=decoder.decodeObjectOfClasses(NSSet(array: [NSArray.classForCoder(),NSNumber.self]), forKey: "triggersIndexes")! as! [Int]
		self.ownedTriggersIndexes=decoder.decodeObjectOfClasses(NSSet(array: [NSArray.classForCoder(),NSNumber.self]), forKey: "ownedTriggersIndexes")! as! [Int]
		self.lastIntegratedTriggerIndex=decoder.decodeIntegerForKey("lastIntegratedTriggerIndex") 
		self.receivedTriggers=decoder.decodeObjectOfClasses(NSSet(array: [NSArray.classForCoder(),Trigger.classForCoder()]), forKey: "receivedTriggers")! as! [Trigger]
		self.triggeredDataBuffer=decoder.decodeObjectOfClass(NSData.self, forKey:"triggeredDataBuffer") as NSData?

        self.enableSuperVisionAndCommit()
    }

    override public func encodeWithCoder(coder: NSCoder) {
        super.encodeWithCoder(coder)
		coder.encodeObject(self.spaceUID,forKey:"spaceUID")
		if let currentUser = self.currentUser {
			coder.encodeObject(currentUser,forKey:"currentUser")
		}
		coder.encodeObject(self.identificationMethod.rawValue ,forKey:"identificationMethod")
		if let identificationValue = self.identificationValue {
			coder.encodeObject(identificationValue,forKey:"identificationValue")
		}
		coder.encodeObject(self.rootObjectUID,forKey:"rootObjectUID")
		if let collaborationServerURL = self.collaborationServerURL {
			coder.encodeObject(collaborationServerURL,forKey:"collaborationServerURL")
		}
		coder.encodeObject(self.collectionsMetadata,forKey:"collectionsMetadata")
		coder.encodeBool(self.online,forKey:"online")
		coder.encodeBool(self.pushOnChanges,forKey:"pushOnChanges")
		coder.encodeObject(self.stateDictionary,forKey:"stateDictionary")
		coder.encodeObject(self.URLBookmarkData,forKey:"URLBookmarkData")
		coder.encodeBool(self.saveThePassword,forKey:"saveThePassword")
		if let preferredFileName = self.preferredFileName {
			coder.encodeObject(preferredFileName,forKey:"preferredFileName")
		}
		coder.encodeObject(self.triggersIndexes,forKey:"triggersIndexes")
		coder.encodeObject(self.ownedTriggersIndexes,forKey:"ownedTriggersIndexes")
		coder.encodeInteger(self.lastIntegratedTriggerIndex,forKey:"lastIntegratedTriggerIndex")
		coder.encodeObject(self.receivedTriggers,forKey:"receivedTriggers")
		if let triggeredDataBuffer = self.triggeredDataBuffer {
			coder.encodeObject(triggeredDataBuffer,forKey:"triggeredDataBuffer")
		}
    }


    override public class func supportsSecureCoding() -> Bool{
        return true
    }


    required public init() {
        super.init()
    }

    // MARK: Identifiable

    override public class var collectionName:String{
        return "registryMetadatas"
    }

    override public var d_collectionName:String{
        return RegistryMetadata.collectionName
    }


}

