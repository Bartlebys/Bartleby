//
//  Operation.swift
//  Bartleby
//
// THIS FILE AS BEEN GENERATED BY BARTLEBYFLEXIONS for b@bartlebys.org
// DO NOT MODIFY THIS FILE YOUR MODIFICATIONS WOULD BE ERASED ON NEXT GENERATION!
//
// Copyright (c) 2016  Bartleby's | https://bartlebys.org  All rights reserved.
//
import Foundation
#if !USE_EMBEDDED_MODULES
import Alamofire
import ObjectMapper
#endif

// MARK: Bartleby's Core: an object used to provision serialized operation. All its properties are not observable
@objc(Operation) public class Operation : JObject{

    // Universal type support
    override public class func typeName() -> String {
        return "Operation"
    }

	//The dictionary representation of a serialized action call
	dynamic public var toDictionary:[String:AnyObject]?
	//The dictionary representation of the last response serialized data
	public var responseDictionary:[String:AnyObject]?
	dynamic public var baseUrl:NSURL?
	//The invocation Status
	public enum Status:String{
		case None = "none"
		case Pending = "pending"
		case InProgress = "inProgress"
		case Successful = "successful"
		case Unsucessful = "unsucessful"
	}
	public var status:Status = .None
	//The registry UID
	public var registryUID:String = "\(Default.NO_UID)"
	//The invocation counter
	dynamic public var counter:Int = 0
	//The creationdate
	dynamic public var creationDate:NSDate?
	//The last invocation date
	dynamic public var lastInvocationDate:NSDate?


    // MARK: Mappable

    required public init?(_ map: Map) {
        super.init(map)
    }

    override public func mapping(map: Map) {
        super.mapping(map)
        self.disableSupervisionAndCommit()
		self.toDictionary <- ( map["toDictionary"] )
		self.responseDictionary <- ( map["responseDictionary"] )
		self.baseUrl <- ( map["baseUrl"], URLTransform() )
		self.status <- ( map["status"] )
		self.registryUID <- ( map["registryUID"] )
		self.counter <- ( map["counter"] )
		self.creationDate <- ( map["creationDate"], ISO8601DateTransform() )
		self.lastInvocationDate <- ( map["lastInvocationDate"], ISO8601DateTransform() )
        self.enableSuperVisionAndCommit()
    }


    // MARK: NSSecureCoding

    required public init?(coder decoder: NSCoder) {
        super.init(coder: decoder)
        self.disableSupervisionAndCommit()
		self.toDictionary=decoder.decodeObjectOfClasses(NSSet(array: [NSDictionary.classForCoder(),NSString.classForCoder(),NSNumber.classForCoder(),NSObject.classForCoder(),NSSet.classForCoder()]), forKey: "toDictionary")as? [String:AnyObject]
		self.responseDictionary=decoder.decodeObjectOfClasses(NSSet(array: [NSDictionary.classForCoder(),NSString.classForCoder(),NSNumber.classForCoder(),NSObject.classForCoder(),NSSet.classForCoder()]), forKey: "responseDictionary")as? [String:AnyObject]
		self.baseUrl=decoder.decodeObjectOfClass(NSURL.self, forKey:"baseUrl") as NSURL?
		self.status=Operation.Status(rawValue:String(decoder.decodeObjectOfClass(NSString.self, forKey: "status")! as NSString))! 
		self.registryUID=String(decoder.decodeObjectOfClass(NSString.self, forKey: "registryUID")! as NSString)
		self.counter=decoder.decodeIntegerForKey("counter") 
		self.creationDate=decoder.decodeObjectOfClass(NSDate.self, forKey:"creationDate") as NSDate?
		self.lastInvocationDate=decoder.decodeObjectOfClass(NSDate.self, forKey:"lastInvocationDate") as NSDate?

        self.enableSuperVisionAndCommit()
    }

    override public func encodeWithCoder(coder: NSCoder) {
        super.encodeWithCoder(coder)
		if let toDictionary = self.toDictionary {
			coder.encodeObject(toDictionary,forKey:"toDictionary")
		}
		if let responseDictionary = self.responseDictionary {
			coder.encodeObject(responseDictionary,forKey:"responseDictionary")
		}
		if let baseUrl = self.baseUrl {
			coder.encodeObject(baseUrl,forKey:"baseUrl")
		}
		coder.encodeObject(self.status.rawValue ,forKey:"status")
		coder.encodeObject(self.registryUID,forKey:"registryUID")
		coder.encodeInteger(self.counter,forKey:"counter")
		if let creationDate = self.creationDate {
			coder.encodeObject(creationDate,forKey:"creationDate")
		}
		if let lastInvocationDate = self.lastInvocationDate {
			coder.encodeObject(lastInvocationDate,forKey:"lastInvocationDate")
		}
    }


    override public class func supportsSecureCoding() -> Bool{
        return true
    }


    required public init() {
        super.init()
    }

    // MARK: Identifiable

    override public class var collectionName:String{
        return "operations"
    }

    override public var d_collectionName:String{
        return Operation.collectionName
    }


}

