//
//  User.swift
//  Bartleby
//
// THIS FILE AS BEEN GENERATED BY BARTLEBYFLEXIONS for [Benoit Pereira da Silva] (https://pereira-da-silva.com/contact)
// DO NOT MODIFY THIS FILE YOUR MODIFICATIONS WOULD BE ERASED ON NEXT GENERATION!
//
// Copyright (c) 2016  [Bartleby's org] (https://bartlebys.org)   All rights reserved.
//
import Foundation
#if !USE_EMBEDDED_MODULES
#endif

// MARK: Bartleby's Core: a user in a specified data Space

@objc open class User: ManagedModel {
    // Universal type support
    open override class func typeName() -> String {
        return "User"
    }

    // The spaceUID. A user with the same credentials can exists within multiple Data space.
    @objc open dynamic var spaceUID: String = Bartleby.createUID() {
        didSet {
            if !self.wantsQuietChanges && spaceUID != oldValue {
                self.provisionChanges(forKey: "spaceUID", oldValue: oldValue, newValue: spaceUID)
            }
        }
    }

    //the verification method
    public enum VerificationMethod: String {
        case none
        case byPhoneNumber
        case byEmail
    }

    open var verificationMethod: VerificationMethod = .byPhoneNumber {
        didSet {
            if !self.wantsQuietChanges && verificationMethod != oldValue {
                self.provisionChanges(forKey: "verificationMethod", oldValue: oldValue.rawValue, newValue: verificationMethod.rawValue)
            }
        }
    }

    // The localAssociationID is an UID used to group accounts that are stored in the KeyChain. The first Created Account determines that UID
    @objc open dynamic var localAssociationID: String = Default.NO_UID {
        didSet {
            if !self.wantsQuietChanges && localAssociationID != oldValue {
                self.provisionChanges(forKey: "localAssociationID", oldValue: oldValue, newValue: localAssociationID)
            }
        }
    }

    @objc open dynamic var firstname: String = Bartleby.randomStringWithLength(5) {
        didSet {
            if !self.wantsQuietChanges && firstname != oldValue {
                self.provisionChanges(forKey: "firstname", oldValue: oldValue, newValue: firstname)
            }
        }
    }

    @objc open dynamic var lastname: String = Bartleby.randomStringWithLength(5) {
        didSet {
            if !self.wantsQuietChanges && lastname != oldValue {
                self.provisionChanges(forKey: "lastname", oldValue: oldValue, newValue: lastname)
            }
        }
    }

    // The user's email.
    @objc open dynamic var email: String = "" {
        didSet {
            if !self.wantsQuietChanges && email != oldValue {
                self.provisionChanges(forKey: "email", oldValue: oldValue, newValue: email)
            }
        }
    }

    // The user's pseudo
    @objc open dynamic var pseudo: String = "" {
        didSet {
            if !self.wantsQuietChanges && pseudo != oldValue {
                self.provisionChanges(forKey: "pseudo", oldValue: oldValue, newValue: pseudo)
            }
        }
    }

    // The user's phone country code
    @objc open dynamic var phoneCountryCode: String = "" {
        didSet {
            if !self.wantsQuietChanges && phoneCountryCode != oldValue {
                self.provisionChanges(forKey: "phoneCountryCode", oldValue: oldValue, newValue: phoneCountryCode)
            }
        }
    }

    // The user's phone number
    @objc open dynamic var phoneNumber: String = "" {
        didSet {
            if !self.wantsQuietChanges && phoneNumber != oldValue {
                self.provisionChanges(forKey: "phoneNumber", oldValue: oldValue, newValue: phoneNumber)
            }
        }
    }

    // The user password (erased by the server on READ operations so that string needs imperatively to be Optional)
    @objc open dynamic var password: String? {
        didSet {
            if !wantsQuietChanges && password != oldValue {
                provisionChanges(forKey: "password", oldValue: oldValue, newValue: password)
            }
        }
    }

    // User Status
    public enum Status: String {
        case new
        case actived
        case suspended
    }

    open var status: Status = .new {
        didSet {
            if !self.wantsQuietChanges && status != oldValue {
                self.provisionChanges(forKey: "status", oldValue: oldValue.rawValue, newValue: status.rawValue)
            }
        }
    }

    // Notes
    @objc open dynamic var notes: String? {
        didSet {
            if !wantsQuietChanges && notes != oldValue {
                provisionChanges(forKey: "notes", oldValue: oldValue, newValue: notes)
            }
        }
    }

    // set to true on the first successfull login in the session (this property is not serialized)
    @objc open dynamic var loginHasSucceed: Bool = false

    // An isolated User is not associated to any Collaborative server
    @objc open dynamic var isIsolated: Bool = false {
        didSet {
            if !self.wantsQuietChanges && isIsolated != oldValue {
                self.provisionChanges(forKey: "isIsolated", oldValue: oldValue, newValue: isIsolated)
            }
        }
    }

    // Can a user memorize her/his password
    @objc open dynamic var supportsPasswordMemorization: Bool = Bartleby.configuration.SUPPORTS_PASSWORD_MEMORIZATION_BY_DEFAULT {
        didSet {
            if !self.wantsQuietChanges && supportsPasswordMemorization != oldValue {
                self.provisionChanges(forKey: "supportsPasswordMemorization", oldValue: oldValue, newValue: supportsPasswordMemorization)
            }
        }
    }

    // Can a user update her/his  own password
    @objc open dynamic var supportsPasswordUpdate: Bool = Bartleby.configuration.SUPPORTS_PASSWORD_UPDATE_BY_DEFAULT {
        didSet {
            if !self.wantsQuietChanges && supportsPasswordUpdate != oldValue {
                self.provisionChanges(forKey: "supportsPasswordUpdate", oldValue: oldValue, newValue: supportsPasswordUpdate)
            }
        }
    }

    // If a local user has the same credentials can her/his password be syndicated
    @objc open dynamic var supportsPasswordSyndication: Bool = Bartleby.configuration.SUPPORTS_PASSWORD_SYNDICATION_BY_DEFAULT {
        didSet {
            if !self.wantsQuietChanges && supportsPasswordSyndication != oldValue {
                self.provisionChanges(forKey: "supportsPasswordSyndication", oldValue: oldValue, newValue: supportsPasswordSyndication)
            }
        }
    }

    // A JFIF base 64 encoded picture of the user
    @objc open dynamic var base64Image: String? {
        didSet {
            if !wantsQuietChanges && base64Image != oldValue {
                provisionChanges(forKey: "base64Image", oldValue: oldValue, newValue: base64Image)
            }
        }
    }

    // MARK: - Codable

    public enum UserCodingKeys: String, CodingKey {
        case spaceUID
        case verificationMethod
        case localAssociationID
        case firstname
        case lastname
        case email
        case pseudo
        case phoneCountryCode
        case phoneNumber
        case password
        case status
        case notes
        case loginHasSucceed
        case isIsolated
        case supportsPasswordMemorization
        case supportsPasswordUpdate
        case supportsPasswordSyndication
        case base64Image
    }

    public required init(from decoder: Decoder) throws {
        try super.init(from: decoder)
        try quietThrowingChanges {
            let values = try decoder.container(keyedBy: UserCodingKeys.self)
            self.spaceUID = try values.decode(String.self, forKey: .spaceUID)
            self.verificationMethod = User.VerificationMethod(rawValue: try values.decode(String.self, forKey: .verificationMethod)) ?? .byPhoneNumber
            self.localAssociationID = try values.decode(String.self, forKey: .localAssociationID)
            self.firstname = try values.decode(String.self, forKey: .firstname)
            self.lastname = try values.decode(String.self, forKey: .lastname)
            self.email = try values.decode(String.self, forKey: .email)
            self.pseudo = try values.decode(String.self, forKey: .pseudo)
            self.phoneCountryCode = try values.decode(String.self, forKey: .phoneCountryCode)
            self.phoneNumber = try values.decode(String.self, forKey: .phoneNumber)
            self.password = try self.decodeCryptedStringIfPresent(codingKey: .password, from: values)
            self.status = User.Status(rawValue: try values.decode(String.self, forKey: .status)) ?? .new
            self.notes = try values.decodeIfPresent(String.self, forKey: .notes)
            self.isIsolated = try values.decode(Bool.self, forKey: .isIsolated)
            self.supportsPasswordMemorization = try values.decode(Bool.self, forKey: .supportsPasswordMemorization)
            self.supportsPasswordUpdate = try values.decode(Bool.self, forKey: .supportsPasswordUpdate)
            self.supportsPasswordSyndication = try values.decode(Bool.self, forKey: .supportsPasswordSyndication)
            self.base64Image = try values.decodeIfPresent(String.self, forKey: .base64Image)
        }
    }

    open override func encode(to encoder: Encoder) throws {
        try super.encode(to: encoder)
        var container = encoder.container(keyedBy: UserCodingKeys.self)
        try container.encode(spaceUID, forKey: .spaceUID)
        try container.encode(verificationMethod.rawValue, forKey: .verificationMethod)
        try container.encode(localAssociationID, forKey: .localAssociationID)
        try container.encode(firstname, forKey: .firstname)
        try container.encode(lastname, forKey: .lastname)
        try container.encode(email, forKey: .email)
        try container.encode(pseudo, forKey: .pseudo)
        try container.encode(phoneCountryCode, forKey: .phoneCountryCode)
        try container.encode(phoneNumber, forKey: .phoneNumber)
        try encodeCryptedStringIfPresent(value: password, codingKey: .password, container: &container)
        try container.encode(status.rawValue, forKey: .status)
        try container.encodeIfPresent(notes, forKey: .notes)
        try container.encode(isIsolated, forKey: .isIsolated)
        try container.encode(supportsPasswordMemorization, forKey: .supportsPasswordMemorization)
        try container.encode(supportsPasswordUpdate, forKey: .supportsPasswordUpdate)
        try container.encode(supportsPasswordSyndication, forKey: .supportsPasswordSyndication)
        try container.encodeIfPresent(base64Image, forKey: .base64Image)
    }

    // MARK: - Exposed (Bartleby's KVC like generative implementation)

    /// Return all the exposed instance variables keys. (Exposed == public and modifiable).
    open override var exposedKeys: [String] {
        var exposed = super.exposedKeys
        exposed.append(contentsOf: ["spaceUID", "verificationMethod", "localAssociationID", "firstname", "lastname", "email", "pseudo", "phoneCountryCode", "phoneNumber", "password", "status", "notes", "loginHasSucceed", "isIsolated", "supportsPasswordMemorization", "supportsPasswordUpdate", "supportsPasswordSyndication", "base64Image"])
        return exposed
    }

    /// Set the value of the given key
    ///
    /// - parameter value: the value
    /// - parameter key:   the key
    ///
    /// - throws: throws an Exception when the key is not exposed
    open override func setExposedValue(_ value: Any?, forKey key: String) throws {
        switch key {
        case "spaceUID":
            if let casted = value as? String {
                spaceUID = casted
            }
        case "verificationMethod":
            if let casted = value as? User.VerificationMethod {
                verificationMethod = casted
            }
        case "localAssociationID":
            if let casted = value as? String {
                localAssociationID = casted
            }
        case "firstname":
            if let casted = value as? String {
                firstname = casted
            }
        case "lastname":
            if let casted = value as? String {
                lastname = casted
            }
        case "email":
            if let casted = value as? String {
                email = casted
            }
        case "pseudo":
            if let casted = value as? String {
                pseudo = casted
            }
        case "phoneCountryCode":
            if let casted = value as? String {
                phoneCountryCode = casted
            }
        case "phoneNumber":
            if let casted = value as? String {
                phoneNumber = casted
            }
        case "password":
            if let casted = value as? String {
                password = casted
            }
        case "status":
            if let casted = value as? User.Status {
                status = casted
            }
        case "notes":
            if let casted = value as? String {
                notes = casted
            }
        case "loginHasSucceed":
            if let casted = value as? Bool {
                loginHasSucceed = casted
            }
        case "isIsolated":
            if let casted = value as? Bool {
                isIsolated = casted
            }
        case "supportsPasswordMemorization":
            if let casted = value as? Bool {
                supportsPasswordMemorization = casted
            }
        case "supportsPasswordUpdate":
            if let casted = value as? Bool {
                supportsPasswordUpdate = casted
            }
        case "supportsPasswordSyndication":
            if let casted = value as? Bool {
                supportsPasswordSyndication = casted
            }
        case "base64Image":
            if let casted = value as? String {
                base64Image = casted
            }
        default:
            return try super.setExposedValue(value, forKey: key)
        }
    }

    /// Returns the value of an exposed key.
    ///
    /// - parameter key: the key
    ///
    /// - throws: throws Exception when the key is not exposed
    ///
    /// - returns: returns the value
    open override func getExposedValueForKey(_ key: String) throws -> Any? {
        switch key {
        case "spaceUID":
            return spaceUID
        case "verificationMethod":
            return verificationMethod
        case "localAssociationID":
            return localAssociationID
        case "firstname":
            return firstname
        case "lastname":
            return lastname
        case "email":
            return email
        case "pseudo":
            return pseudo
        case "phoneCountryCode":
            return phoneCountryCode
        case "phoneNumber":
            return phoneNumber
        case "password":
            return password
        case "status":
            return status
        case "notes":
            return notes
        case "loginHasSucceed":
            return loginHasSucceed
        case "isIsolated":
            return isIsolated
        case "supportsPasswordMemorization":
            return supportsPasswordMemorization
        case "supportsPasswordUpdate":
            return supportsPasswordUpdate
        case "supportsPasswordSyndication":
            return supportsPasswordSyndication
        case "base64Image":
            return base64Image
        default:
            return try super.getExposedValueForKey(key)
        }
    }

    // MARK: - Initializable

    public required init() {
        super.init()
    }

    // MARK: - UniversalType

    open override class var collectionName: String {
        return "users"
    }

    open override var d_collectionName: String {
        return User.collectionName
    }
}
