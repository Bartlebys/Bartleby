//
//  BartlebyDocument.swift
//
//  The is the central piece of the Document oriented architecture.
//  We provide a universal implementation with conditionnal compilation
//
//  The document stores references to Bartleby's style ManagedCollections.
//  This allow to use intensively bindings and distributed data automation.
//  With the mediation of standard Bindings approach with NSArrayControler
//
//  We prefer to centralize the complexity of data handling in the document.
//  Thats why for example we implement projectBindingsArrayController.didSet with an CGD dispatching
//  We could have set the binding programmatically in the WindowController
//  But we consider for clarity that the Storyboarded Bindings Settings should be as exhaustive as possible.
//  And the potential complexity masked.
//
//  Generated by flexions
//

import Foundation

#if os(OSX)
import AppKit
#else
import UIKit
#endif

import Foundation
#if !USE_EMBEDDED_MODULES
	import Alamofire
	import ObjectMapper
#endif

@objc(BartlebyDocument) open class BartlebyDocument : BXDocument,BoxDelegate {



    //MARK: - Initializers


    #if os(OSX)

    required public override init() {
        super.init()

        Bartleby.sharedInstance.declare(self)
        addGlobalLogsObserver(self) // Add the document to globals logs observer
        BartlebyDocument.declareTypes()

        self.metadata.document=self

        // Setup the spaceUID if necessary
        if (self.metadata.spaceUID==Default.NO_UID) {
            self.metadata.spaceUID=self.metadata.UID
        }
        // Setup the default collaboration server
        self.metadata.collaborationServerURL=Bartleby.configuration.API_BASE_URL

        // Configure the schemas
        self.configureSchema()

    }
    #else


    public override init(fileURL url: URL) {
        super.init(fileURL: url as URL)

        Bartleby.sharedInstance.declare(self)
        addGlobalLogsObserver(self) // Add the document to globals logs observer
        BartlebyDocument.declareTypes()

        self.metadata.document=self

        // Setup the spaceUID if necessary
        if (self.metadata.spaceUID==Default.NO_UID) {
            self.metadata.spaceUID=self.metadata.UID
        }

        // Setup the default collaboration server
        self.metadata.collaborationServerURL=Bartleby.configuration.API_BASE_URL

        // Configure the schemas
        self.configureSchema()
    }

    #endif


    // The file extension for crypted data
    open static var DATA_EXTENSION: String { return (Bartleby.cryptoDelegate is NoCrypto) ? ".json" : ".data" }

    // The metadata file name
    internal var _metadataFileName: String { return "metadata" + BartlebyDocument.DATA_EXTENSION }

    // The Document Metadata
    dynamic open var metadata=DocumentMetadata()

    // Bartleby's Synchronized File System for this document.
    open lazy var bsfs:BSFS=BSFS(in:self)

    // The bsfs data file name
    internal var _bsfsDataFileName: String { return "localBSFS" + BartlebyDocument.DATA_EXTENSION }

    // Hook the triggers
    public var triggerHooks=[TriggerHook]()


    // Triggered Data is used to store data before data integration
    internal var _triggeredDataBuffer:[Trigger]=[Trigger]()


    // This is the BartlebyDocument UID
    // We use the root object UID as observationUID
    // You should have set up the rootObjectUID before any trigger emitted.
    // The triggers are observable via this UID
    open var UID:String{
        get{
            return self.metadata.rootObjectUID
        }
    }

    // The spaceUID can be shared between multiple documents-registries
    // It defines a dataSpace in wich a user can perform operations.
    // A user can `live` in one data space only.
    open var spaceUID: String {
        get {
            return self.metadata.spaceUID
        }
    }


    /// The current document user
    open var currentUser: User {
        get {
            if let currentUser=self.metadata.currentUser {
                return currentUser
            } else {
                return User()
            }
        }
    }

    // Set to true when the data has been loaded once or more.
    open var hasBeenLoaded: Bool=false

    // An in memory flag to distinguish dotBart import case
    open var dotBart=false

    /// The underlining storage hashed by collection name
    internal var _collections=[String:BartlebyCollection]()

    /// We store the URL of the active security bookmarks
    internal var _activeSecurityBookmarks=[URL]()

    // Reachability Manager
    internal var _reachabilityManager:NetworkReachabilityManager?

    // MARK: Universal Type management.

    fileprivate static var _associatedTypesMap=[String:String]()

    // MARK: URI

    // The collection server base URL
    open dynamic var baseURL:URL{
        return self.metadata.collaborationServerURL ?? Bartleby.configuration.API_BASE_URL
    }

    // The online flag is driving the "connection" process
    // It connects to the SSE and starts the pushLoop
    open var online:Bool=false{
        willSet{
            // Transition on line
            if newValue==true && online==false{
                self._connectToSSE()
            }
            // Transition off line
            if newValue==false && online==true{
                self.log("SSE is transitioning offline",file:#file,function:#function,line:#line,category: "SSE")
                self._closeSSE()
            }
            if newValue==online{
                self.log("Neutral online var setting",file:#file,function:#function,line:#line,category: "SSE")
            }
        }
        didSet{
            self.metadata.online=online
            self.startPushLoopIfNecessary()
        }
    }

    // MARK:

    /**
     Sets the root object UID.
     The previsou

     - parameter UID: the UID

     - throws: throws value description
     */
    open func setRootObjectUID(_ UID:String) throws {
        if (self.metadata.rootObjectUID==Default.NO_UID){
            self.metadata.rootObjectUID=UID
            Bartleby.sharedInstance.replaceDocumentUID(Default.NO_UID, by: UID)
        }else{
            throw DocumentError.attemptToSetUpRootObjectUIDMoreThanOnce
        }
    }

    /**
     Declares a collectible type with disymetric runTimeTypeName() and typeName()

     You can associate disymetric Type name
     For example if you create an Alias class that uses Generics
     runTimeTypeName() & typeName() can diverges.

     **IMPORTANT** You Cannot use NSecureCoding for diverging classes

     The role of declareTypes() is to declare diverging members.
     Or to produce an adaptation layer (from a type to another)

     ## Let's take an advanced example:

     ```
     public class Alias<T:Collectible>:BartlebyObject {

     override public class func typeName() -> String {
     return "Alias<\(T.typeName())>"
     }

     ```
     Let's say we instantiate an Alias<Tag>

     To insure **cross product deserialization**
     Eg:  "_TtGC11BartlebyKit5AliasCS_3Tag_" or "_TtGC5bsync5AliasCS_3Tag_" are transformed to "Alias<Tag>"

     To associate those disymetric type you can add the class declareTypes
     And implement typeName() and runTimeTypeName()

     ```
     public class func declareTypes() {
     BartlebyDocument.declareCollectibleType(Object)
     BartlebyDocument.declareCollectibleType(Alias<Object>)

     ```
     - parameter type: a Collectible type
     */
    open static func declareCollectibleType(_ type: Collectible.Type) {
        let prototype=type.init()
        let name = prototype.runTimeTypeName()
        BartlebyDocument._associatedTypesMap[type(of: prototype).typeName()]=name
    }


    /**
     Bartleby is able to associate the types to allow translitterations

     - parameter universalTypeName: the universal typename

     - returns: the resolved type name
     */
    open static func resolveTypeName(from universalTypeName: String) -> String {
        if let name = BartlebyDocument._associatedTypesMap[universalTypeName] {
            return name
        } else {
            return universalTypeName
        }
    }

    //MARK: - Preparations


    open func registerCollections() throws {
        for metadatum in self.metadata.collectionsMetadata {
            if let proxy=metadatum.proxy {
                if var proxy = proxy as? BartlebyCollection {
                    self._addCollection(proxy)
                    self._refreshIdentifier(&proxy)
                } else {
                    throw DocumentError.collectionProxyTypeError
                }
            } else {
                throw DocumentError.missingCollectionProxy(collectionName: metadatum.collectionName)
            }
        }
    }

    internal func _refreshProxies()throws {
        for metadatum in self.metadata.collectionsMetadata {
            if var proxy=self.collectionByName(metadatum.collectionName) {
                self._refreshIdentifier(&proxy)
            } else {
                throw DocumentError.missingCollectionProxy(collectionName: metadatum.collectionName)
            }
        }
    }

    fileprivate func _refreshIdentifier(_ collectionProxy: inout BartlebyCollection) {
        collectionProxy.undoManager=self.undoManager
        collectionProxy.document=self
    }


    // MARK: - Collections Public API

    open func getCollection<T: CollectibleCollection>  () throws -> T {
        guard var collection=self.collectionByName(T.collectionName) as? T else {
            throw DocumentError.unExistingCollection(collectionName: T.collectionName)
        }
        collection.undoManager=self.undoManager
        return collection
    }



    /**
     Returns the collection Names.

     - returns: the names
     */
    open func getCollectionsNames()->[String]{
        return self._collections.map {$0.0}
    }

    // MARK: Private Collections Implementation
    // Weak Casting for internal behavior
    // Those dynamic method are only used internally

    internal func _addCollection(_ collection: BartlebyCollection) {
        let collectionName=collection.d_collectionName
        _collections[collectionName]=collection
    }


    // Any call should always be casted to a CollectibleCollection
    func collectionByName(_ name: String) -> BartlebyCollection? {
        if _collections.keys.contains(name){
            return _collections[name]
        }
        return nil
    }


    /**
     Universal change
     */
    open func hasChanged() -> () {
        #if os(OSX)
            self.updateChangeCount(NSDocumentChangeType.changeDone)
        #else
            self.updateChangeCount(UIDocumentChangeKind.done)
        #endif
    }



    /**
     Returns the collection file name

     - parameter metadatum: the collectionMetadatim

     - returns: the crypted and the non crypted file name in a tupple.
     */
    internal func _collectionFileNames(_ metadatum: CollectionMetadatum) -> (notCrypted: String, crypted: String) {
        let cryptedExtension=BartlebyDocument.DATA_EXTENSION
        let nonCryptedExtension=".\(Bartleby.defaultSerializer.fileExtension)"
        let cryptedFileName=metadatum.collectionName + cryptedExtension
        let nonCryptedFileName=metadatum.collectionName + nonCryptedExtension
        return (notCrypted:nonCryptedFileName, crypted:cryptedFileName)
    }

    /**
     BartlebyDocument did load
     */
    open func documentDidLoad() {
        self.hasBeenLoaded=true
    }

    /**
     BartlebyDocument will save
     */
    open func documentWillSave() {

    }

    // MARK: - BSFS: BoxDelegate

    /// BSFS sends to BoxDelegate
    /// The delegate invokes proceed asynchronously giving the time to perform required actions
    ///
    /// - Parameter node: the node that will be moved or copied
    open func moveIsReady(node:Node,to destinationPath:String,proceed:()->()){
        // If necessary we can wait
        proceed()
    }


    /// BSFS sends to BoxDelegate
    /// The delegate invokes proceed asynchronously giving the time to perform required actions
    ///
    /// - Parameter node: the node that will be moved or copied
    open func copyIsReady(node:Node,to destinationPath:String,proceed:()->()){
        // If necessary we can wait
        proceed()
    }
                    
    /// BSFS sends to BoxDelegate
    /// The delegate invokes proceed asynchronously giving the time to perform required actions
    ///
    /// - Parameter node: the node that will be Updated
    open func deletionIsReady(node:Node,proceed:()->()){
        // If necessary we can wait
        proceed()
    }

    /// BSFS sends to BoxDelegate
    /// The delegate invokes proceed asynchronously giving the time to perform required actions
    ///
    /// - Parameter node: the node that will be Created or Updated
    open func nodeIsReady(node: Node, proceed: () -> ()) {
        proceed()
    }

    /// Should we allow the replacement of content node
    ///
    /// - Parameters:
    ///   - node: the node
    ///   - path: the path
    ///   - accessor: the accessor
    /// - Returns: true if allowed
    open func allowReplaceContent(of node:Node, withContentAt path:String, by accessor:NodeAccessor)->Bool{
        return false // Return false by default
    }

    // MARK: - Synchronization

    // SSE server sent event source
    internal var _sse:EventSource?

    // The EventSource URL for Server Sent Events
    open dynamic lazy var sseURL:URL=URL(string: self.baseURL.absoluteString+"/SSETriggers?spaceUID=\(self.spaceUID)&observationUID=\(self.UID)&lastIndex=\(self.metadata.lastIntegratedTriggerIndex)&runUID=\(Bartleby.runUID)&showDetails=false")!

    open var synchronizationHandlers:Handlers=Handlers.withoutCompletion()

    internal var _timer:Timer?

    // MARK: - Local Persistency

#if os(OSX)


    // MARK:  NSDocument

    // MARK: Serialization
     override open func fileWrapper(ofType typeName: String) throws -> FileWrapper {

        self.documentWillSave()
        let fileWrapper=FileWrapper(directoryWithFileWrappers:[:])
        if var fileWrappers=fileWrapper.fileWrappers {

            // ##############
            // # Metadata
            // ##############

            // Try to store a preferred filename
            self.metadata.preferredFileName=self.fileURL?.lastPathComponent
            var metadataData=self.metadata.serialize()

            metadataData = try Bartleby.cryptoDelegate.encryptData(metadataData)

            // Remove the previous metadata
            if let wrapper=fileWrappers[self._metadataFileName] {
                fileWrapper.removeFileWrapper(wrapper)
            }
            let metadataFileWrapper=FileWrapper(regularFileWithContents: metadataData)
            metadataFileWrapper.preferredFilename=self._metadataFileName
            fileWrapper.addFileWrapper(metadataFileWrapper)

            // ##############
            // # BSFS DATA
            // ##############

            if let wrapper=fileWrappers[self._bsfsDataFileName]{
            fileWrapper.removeFileWrapper(wrapper)
            }

            let data = try Bartleby.cryptoDelegate.encryptData(self.bsfs.saveState())
            let bsfsFileWrapper=FileWrapper(regularFileWithContents:data)
            bsfsFileWrapper.preferredFilename=self._bsfsDataFileName
            fileWrapper.addFileWrapper(bsfsFileWrapper)


            // ##############
            // # Collections
            // ##############

            for metadatum: CollectionMetadatum in self.metadata.collectionsMetadata {

                if !metadatum.inMemory {
                    let collectionfileName=self._collectionFileNames(metadatum).crypted
                    // MONOLITHIC STORAGE
                    if metadatum.storage == CollectionMetadatum.Storage.monolithicFileStorage {

                        if let collection = self.collectionByName(metadatum.collectionName) as? CollectibleCollection {

                            // We use multiple files

                            // Use the faster possible approach.
                            // The resulting data is not a valid String check CryptoDelegate for details.
                            let collectionString = collection.serializeToUFf8String()
                            let collectionData = try Bartleby.cryptoDelegate.encryptStringToData(collectionString)

                            // Remove the previous data
                            if let wrapper=fileWrappers[collectionfileName] {
                                fileWrapper.removeFileWrapper(wrapper)
                            }

                            let collectionFileWrapper=FileWrapper(regularFileWithContents: collectionData)
                            collectionFileWrapper.preferredFilename=collectionfileName
                            fileWrapper.addFileWrapper(collectionFileWrapper)
                        } else {
                            // NO COLLECTION
                        }
                    } else {
                        // INCREMENTAL STORAGE CURRENTLY NOT SUPPORTED
                    }

                }
            }
        }
        return fileWrapper
    }

    // MARK: Deserialization


    /**
     Standard Bundles loading

     - parameter fileWrapper: the file wrapper
     - parameter typeName:    the type name

     - throws: misc exceptions
     */
    override open func read(from fileWrapper: FileWrapper, ofType typeName: String) throws {
        if let fileWrappers=fileWrapper.fileWrappers {

            // ##############
            // # Metadata
            // ##############

            if let wrapper=fileWrappers[_metadataFileName] {
                if var metadataData=wrapper.regularFileContents {
                    metadataData = try Bartleby.cryptoDelegate.decryptData(metadataData)
                    let r = try Bartleby.defaultSerializer.deserialize(metadataData)
                    if let metadata=r as? DocumentMetadata {
                        self.metadata = metadata
                        self.metadata.document = self
                    } else {
                        // There is an error
                        self.log("ERROR \(r)", file: #file, function: #function, line: #line)
                        return
                    }
                    let documentUID=self.metadata.rootObjectUID
                    Bartleby.sharedInstance.replaceDocumentUID(Default.NO_UID, by: documentUID)
                    self.metadata.currentUser?.document=self
                }
            } else {
                // ERROR
            }

            // ##############
            // # BSFS DATA
            // ##############

            if let wrapper=fileWrappers[_bsfsDataFileName] {
                if var data=wrapper.regularFileContents {
                    data = try Bartleby.cryptoDelegate.decryptData(data)
                    try self.bsfs.restoreStateFrom(data: data)
                }
            } else {
                // ERROR
            }

            // ##############
            // # Collections
            // ##############

            for metadatum in self.metadata.collectionsMetadata {
                // MONOLITHIC STORAGE
                if metadatum.storage == CollectionMetadatum.Storage.monolithicFileStorage {
                    let names=self._collectionFileNames(metadatum)
                    if let wrapper=fileWrappers[names.crypted] ?? fileWrappers[names.notCrypted] {
                        let filename=wrapper.filename
                        if var collectionData=wrapper.regularFileContents {
                            if let proxy=self.collectionByName(metadatum.collectionName) {
                                if let path=filename {
                                    if let ext=path.components(separatedBy: ".").last {
                                        let pathExtension="."+ext
                                        if  pathExtension == BartlebyDocument.DATA_EXTENSION {
                                            // Use the faster possible approach.
                                            // The resulting data is not a valid String check CryptoDelegate for details.
                                            let collectionString = try Bartleby.cryptoDelegate.decryptStringFromData(collectionData)
                                            collectionData = collectionString.data(using:.utf8) ?? Data()
                                        }
                                    }
                                  let _ = try proxy.updateData(collectionData,provisionChanges: false)
                                }
                            } else {
                                throw DocumentError.attemptToLoadAnNonSupportedCollection(collectionName:metadatum.d_collectionName)
                            }
                        }
                    } else {
                        // ERROR
                    }
                } else {
                    // INCREMENTAL STORAGE CURRENTLY NOT SUPPORTED
                }
            }
            do {
                try self._refreshProxies()
            } catch {
                self.log("Proxies refreshing failure \(error)", file: #file, function: #function, line: #line)
            }

            DispatchQueue.main.async(execute: {
                self.documentDidLoad()
            })
        }
    }

#else

    // MARK: iOS UIDocument serialization / deserialization

    // TODO: @bpds(#IOS) UIDocument support

    // SAVE content
    override open func contents(forType typeName: String) throws -> Any {
        return ""
    }

    // READ content
    open override func load(fromContents contents: Any, ofType typeName: String?) throws {

    }

#endif

    // MARK: - Metrics

    open dynamic var metrics=[Metrics]()

    // MARK: - Logs

    open var enableLog: Bool=true

    open var printLogsToTheConsole: Bool=false

    open var logs=[LogEntry]()

    open var logsObservers=[LogEntriesObserver]()

    // MARK: - Consignation

    /// The display duration of volatile messages
    static open let VOLATILE_DISPLAY_DURATION: Double=3

    // MARK:  Simple stack management

    open var trackingIsEnabled: Bool=false

    open var glogTrackedEntries: Bool=false

    open var trackingStack=[(result:Any?, context:Consignable)]()

    // MARK : - new User facility

    /**
    * Creates a new user
    *
    * you should override this method to customize default (name, email, ...)
    */
    open func newUser() -> User {
        let user=User()
        user.silentGroupedChanges {
            user.password=Bartleby.randomStringWithLength(8,signs:Bartleby.configuration.PASSWORD_CHAR_CART)
            if let creator=self.metadata.currentUser {
                user.creatorUID = creator.UID
            }else{
                // Autopoiesis.
                user.creatorUID = user.UID
            }
            user.spaceUID = self.metadata.spaceUID
            if(user.creatorUID != user.UID){
                // We don't want to add the Document's current user
                self.users.add(user, commit:false)
            }else{
                user.document = self
            }
        }
        user.commitRequired()// We defer the commit to allow to take account of overriden possible changes.
        return user
    }

    // MARK  Universal Type Support

     open class func declareTypes() {
    }

    // MARK: - Collection Controllers

    fileprivate var _KVOContext: Int = 0

    // The initial instances are proxies
    // On document deserialization the collection are populated.

	open dynamic var blocks=BlocksManagedCollection(){
		willSet{
			blocks.document=self
		}
	}
	
	open dynamic var boxes=BoxesManagedCollection(){
		willSet{
			boxes.document=self
		}
	}
	
	open dynamic var lockers=LockersManagedCollection(){
		willSet{
			lockers.document=self
		}
	}
	
	open dynamic var nodes=NodesManagedCollection(){
		willSet{
			nodes.document=self
		}
	}
	
	open dynamic var pushOperations=PushOperationsManagedCollection(){
		willSet{
			pushOperations.document=self
		}
	}
	
	open dynamic var users=UsersManagedCollection(){
		willSet{
			users.document=self
		}
	}
	
    // MARK: - Array Controllers and automation (OSX)
 #if os(OSX) && !USE_EMBEDDED_MODULES


    // KVO
    // Those array controllers are Owned by their respective ViewControllers
    // Those view Controller are observed here to insure a consistent persitency


    open var blocksArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            blocksArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the ManagedCollection
            self.blocks.arrayController=blocksArrayController
            // Add observer
            blocksArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .new, context: &self._KVOContext)
            if let indexes=self.metadata.stateDictionary[BartlebyDocument.kSelectedBlocksIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{ indexesSet.add($0) }
                self.blocksArrayController?.setSelectionIndexes(indexesSet as IndexSet)
             }
        }
    }
        
    open var boxesArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            boxesArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the ManagedCollection
            self.boxes.arrayController=boxesArrayController
            // Add observer
            boxesArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .new, context: &self._KVOContext)
            if let indexes=self.metadata.stateDictionary[BartlebyDocument.kSelectedBoxesIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{ indexesSet.add($0) }
                self.boxesArrayController?.setSelectionIndexes(indexesSet as IndexSet)
             }
        }
    }
        
    open var lockersArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            lockersArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the ManagedCollection
            self.lockers.arrayController=lockersArrayController
            // Add observer
            lockersArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .new, context: &self._KVOContext)
            if let indexes=self.metadata.stateDictionary[BartlebyDocument.kSelectedLockersIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{ indexesSet.add($0) }
                self.lockersArrayController?.setSelectionIndexes(indexesSet as IndexSet)
             }
        }
    }
        
    open var nodesArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            nodesArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the ManagedCollection
            self.nodes.arrayController=nodesArrayController
            // Add observer
            nodesArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .new, context: &self._KVOContext)
            if let indexes=self.metadata.stateDictionary[BartlebyDocument.kSelectedNodesIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{ indexesSet.add($0) }
                self.nodesArrayController?.setSelectionIndexes(indexesSet as IndexSet)
             }
        }
    }
        
    open var pushOperationsArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            pushOperationsArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the ManagedCollection
            self.pushOperations.arrayController=pushOperationsArrayController
            // Add observer
            pushOperationsArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .new, context: &self._KVOContext)
            if let indexes=self.metadata.stateDictionary[BartlebyDocument.kSelectedPushOperationsIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{ indexesSet.add($0) }
                self.pushOperationsArrayController?.setSelectionIndexes(indexesSet as IndexSet)
             }
        }
    }
        
    open var usersArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            usersArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the ManagedCollection
            self.users.arrayController=usersArrayController
            // Add observer
            usersArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .new, context: &self._KVOContext)
            if let indexes=self.metadata.stateDictionary[BartlebyDocument.kSelectedUsersIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{ indexesSet.add($0) }
                self.usersArrayController?.setSelectionIndexes(indexesSet as IndexSet)
             }
        }
    }
        


#endif

    // indexes persistency

    
    static open let kSelectedBlocksIndexesKey="selectedBlocksIndexesKey"
    static open let BLOCKS_SELECTED_INDEXES_CHANGED_NOTIFICATION="BLOCKS_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic open var selectedBlocks:[Block]?{
        didSet{
            if let blocks = selectedBlocks {
                 let indexes:[Int]=blocks.map({ (block) -> Int in
                    return self.blocks.index(where:{ return $0.UID == block.UID })!
                })
                self.metadata.stateDictionary[BartlebyDocument.kSelectedBlocksIndexesKey]=indexes
                NotificationCenter.default.post(name:NSNotification.Name(rawValue:BartlebyDocument.BLOCKS_SELECTED_INDEXES_CHANGED_NOTIFICATION), object: nil)
            }
        }
    }
    var firstSelectedBlock:Block? { return self.selectedBlocks?.first }
        
        
    
    static open let kSelectedBoxesIndexesKey="selectedBoxesIndexesKey"
    static open let BOXES_SELECTED_INDEXES_CHANGED_NOTIFICATION="BOXES_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic open var selectedBoxes:[Box]?{
        didSet{
            if let boxes = selectedBoxes {
                 let indexes:[Int]=boxes.map({ (box) -> Int in
                    return self.boxes.index(where:{ return $0.UID == box.UID })!
                })
                self.metadata.stateDictionary[BartlebyDocument.kSelectedBoxesIndexesKey]=indexes
                NotificationCenter.default.post(name:NSNotification.Name(rawValue:BartlebyDocument.BOXES_SELECTED_INDEXES_CHANGED_NOTIFICATION), object: nil)
            }
        }
    }
    var firstSelectedBox:Box? { return self.selectedBoxes?.first }
        
        
    
    static open let kSelectedLockersIndexesKey="selectedLockersIndexesKey"
    static open let LOCKERS_SELECTED_INDEXES_CHANGED_NOTIFICATION="LOCKERS_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic open var selectedLockers:[Locker]?{
        didSet{
            if let lockers = selectedLockers {
                 let indexes:[Int]=lockers.map({ (locker) -> Int in
                    return self.lockers.index(where:{ return $0.UID == locker.UID })!
                })
                self.metadata.stateDictionary[BartlebyDocument.kSelectedLockersIndexesKey]=indexes
                NotificationCenter.default.post(name:NSNotification.Name(rawValue:BartlebyDocument.LOCKERS_SELECTED_INDEXES_CHANGED_NOTIFICATION), object: nil)
            }
        }
    }
    var firstSelectedLocker:Locker? { return self.selectedLockers?.first }
        
        
    
    static open let kSelectedNodesIndexesKey="selectedNodesIndexesKey"
    static open let NODES_SELECTED_INDEXES_CHANGED_NOTIFICATION="NODES_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic open var selectedNodes:[Node]?{
        didSet{
            if let nodes = selectedNodes {
                 let indexes:[Int]=nodes.map({ (node) -> Int in
                    return self.nodes.index(where:{ return $0.UID == node.UID })!
                })
                self.metadata.stateDictionary[BartlebyDocument.kSelectedNodesIndexesKey]=indexes
                NotificationCenter.default.post(name:NSNotification.Name(rawValue:BartlebyDocument.NODES_SELECTED_INDEXES_CHANGED_NOTIFICATION), object: nil)
            }
        }
    }
    var firstSelectedNode:Node? { return self.selectedNodes?.first }
        
        
    
    static open let kSelectedPushOperationsIndexesKey="selectedPushOperationsIndexesKey"
    static open let PUSHOPERATIONS_SELECTED_INDEXES_CHANGED_NOTIFICATION="PUSHOPERATIONS_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic open var selectedPushOperations:[PushOperation]?{
        didSet{
            if let pushOperations = selectedPushOperations {
                 let indexes:[Int]=pushOperations.map({ (pushOperation) -> Int in
                    return self.pushOperations.index(where:{ return $0.UID == pushOperation.UID })!
                })
                self.metadata.stateDictionary[BartlebyDocument.kSelectedPushOperationsIndexesKey]=indexes
                NotificationCenter.default.post(name:NSNotification.Name(rawValue:BartlebyDocument.PUSHOPERATIONS_SELECTED_INDEXES_CHANGED_NOTIFICATION), object: nil)
            }
        }
    }
    var firstSelectedPushOperation:PushOperation? { return self.selectedPushOperations?.first }
        
        
    
    static open let kSelectedUsersIndexesKey="selectedUsersIndexesKey"
    static open let USERS_SELECTED_INDEXES_CHANGED_NOTIFICATION="USERS_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic open var selectedUsers:[User]?{
        didSet{
            if let users = selectedUsers {
                 let indexes:[Int]=users.map({ (user) -> Int in
                    return self.users.index(where:{ return $0.UID == user.UID })!
                })
                self.metadata.stateDictionary[BartlebyDocument.kSelectedUsersIndexesKey]=indexes
                NotificationCenter.default.post(name:NSNotification.Name(rawValue:BartlebyDocument.USERS_SELECTED_INDEXES_CHANGED_NOTIFICATION), object: nil)
            }
        }
    }
    var firstSelectedUser:User? { return self.selectedUsers?.first }
        
        
    // MARK: - Schemas


    /**

    In this func you should :

    #1  Define the Schema
    #2  Register the collections (by calling registerCollections())
    #3  Replace the collections proxies (if you want to use cocoa bindings)

    */
	open func configureSchema(){
        let blockDefinition = CollectionMetadatum()
        blockDefinition.proxy = self.blocks
        // By default we group the observation via the rootObjectUID
        blockDefinition.collectionName = Block.collectionName
        blockDefinition.storage = CollectionMetadatum.Storage.monolithicFileStorage
        blockDefinition.persistsDistantly = true
        blockDefinition.inMemory = false
        
        let boxDefinition = CollectionMetadatum()
        boxDefinition.proxy = self.boxes
        // By default we group the observation via the rootObjectUID
        boxDefinition.collectionName = Box.collectionName
        boxDefinition.storage = CollectionMetadatum.Storage.monolithicFileStorage
        boxDefinition.persistsDistantly = true
        boxDefinition.inMemory = false
        
        let lockerDefinition = CollectionMetadatum()
        lockerDefinition.proxy = self.lockers
        // By default we group the observation via the rootObjectUID
        lockerDefinition.collectionName = Locker.collectionName
        lockerDefinition.storage = CollectionMetadatum.Storage.monolithicFileStorage
        lockerDefinition.persistsDistantly = true
        lockerDefinition.inMemory = false
        
        let nodeDefinition = CollectionMetadatum()
        nodeDefinition.proxy = self.nodes
        // By default we group the observation via the rootObjectUID
        nodeDefinition.collectionName = Node.collectionName
        nodeDefinition.storage = CollectionMetadatum.Storage.monolithicFileStorage
        nodeDefinition.persistsDistantly = true
        nodeDefinition.inMemory = false
        
        let pushOperationDefinition = CollectionMetadatum()
        pushOperationDefinition.proxy = self.pushOperations
        // By default we group the observation via the rootObjectUID
        pushOperationDefinition.collectionName = PushOperation.collectionName
        pushOperationDefinition.storage = CollectionMetadatum.Storage.monolithicFileStorage
        pushOperationDefinition.persistsDistantly = false
        pushOperationDefinition.inMemory = false
        
        let userDefinition = CollectionMetadatum()
        userDefinition.proxy = self.users
        // By default we group the observation via the rootObjectUID
        userDefinition.collectionName = User.collectionName
        userDefinition.storage = CollectionMetadatum.Storage.monolithicFileStorage
        userDefinition.persistsDistantly = true
        userDefinition.inMemory = false
        

        // Proceed to configuration
        do{

			try self.metadata.configureSchema(blockDefinition)
			try self.metadata.configureSchema(boxDefinition)
			try self.metadata.configureSchema(lockerDefinition)
			try self.metadata.configureSchema(nodeDefinition)
			try self.metadata.configureSchema(pushOperationDefinition)
			try self.metadata.configureSchema(userDefinition)

        }catch DocumentError.duplicatedCollectionName(let collectionName){
            self.log("Multiple Attempt to add the Collection named \(collectionName)",file:#file,function:#function,line:#line)
        }catch {
            self.log("\(error)",file:#file,function:#function,line:#line)
        }

        // #2 Registers the collections
        do{
            try self.registerCollections()
        }catch{
        }
    }

    // MARK: - OSX specific

 #if os(OSX) && !USE_EMBEDDED_MODULES

    // MARK: KVO


    override open func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        guard context == &_KVOContext else {
            // If the context does not match, this message
            // must be intended for our superclass.
            super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
            return
        }
        // We prefer to centralize the KVO for selection indexes at the top level
        if let keyPath = keyPath, let object = object {

                    
            if keyPath=="selectionIndexes" && self.blocksArrayController == object as? NSArrayController {
                if let blocks = self.blocksArrayController?.selectedObjects as? [Block] {
                     if let selectedBlock = self.selectedBlocks{
                        if selectedBlock == blocks{
                            return // No changes
                        }
                     }
                    self.selectedBlocks=blocks
                }
                return
            }
            
            
            if keyPath=="selectionIndexes" && self.boxesArrayController == object as? NSArrayController {
                if let boxes = self.boxesArrayController?.selectedObjects as? [Box] {
                     if let selectedBox = self.selectedBoxes{
                        if selectedBox == boxes{
                            return // No changes
                        }
                     }
                    self.selectedBoxes=boxes
                }
                return
            }
            
            
            if keyPath=="selectionIndexes" && self.lockersArrayController == object as? NSArrayController {
                if let lockers = self.lockersArrayController?.selectedObjects as? [Locker] {
                     if let selectedLocker = self.selectedLockers{
                        if selectedLocker == lockers{
                            return // No changes
                        }
                     }
                    self.selectedLockers=lockers
                }
                return
            }
            
            
            if keyPath=="selectionIndexes" && self.nodesArrayController == object as? NSArrayController {
                if let nodes = self.nodesArrayController?.selectedObjects as? [Node] {
                     if let selectedNode = self.selectedNodes{
                        if selectedNode == nodes{
                            return // No changes
                        }
                     }
                    self.selectedNodes=nodes
                }
                return
            }
            
            
            if keyPath=="selectionIndexes" && self.pushOperationsArrayController == object as? NSArrayController {
                if let pushOperations = self.pushOperationsArrayController?.selectedObjects as? [PushOperation] {
                     if let selectedPushOperation = self.selectedPushOperations{
                        if selectedPushOperation == pushOperations{
                            return // No changes
                        }
                     }
                    self.selectedPushOperations=pushOperations
                }
                return
            }
            
            
            if keyPath=="selectionIndexes" && self.usersArrayController == object as? NSArrayController {
                if let users = self.usersArrayController?.selectedObjects as? [User] {
                     if let selectedUser = self.selectedUsers{
                        if selectedUser == users{
                            return // No changes
                        }
                     }
                    self.selectedUsers=users
                }
                return
            }
            
        }

    }

    // MARK:  Delete currently selected items
        open func deleteSelectedBlocks() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedBlocks{
            for item in selected{
                 self.blocks.removeObject(item, commit:true)
            }
        }
    }
        
    open func deleteSelectedBoxes() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedBoxes{
            for item in selected{
                 self.boxes.removeObject(item, commit:true)
            }
        }
    }
        
    open func deleteSelectedLockers() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedLockers{
            for item in selected{
                 self.lockers.removeObject(item, commit:true)
            }
        }
    }
        
    open func deleteSelectedNodes() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedNodes{
            for item in selected{
                 self.nodes.removeObject(item, commit:true)
            }
        }
    }
        
    open func deleteSelectedPushOperations() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedPushOperations{
            for item in selected{
                 self.pushOperations.removeObject(item, commit:true)
            }
        }
    }
        
    open func deleteSelectedUsers() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedUsers{
            for item in selected{
                 self.users.removeObject(item, commit:true)
            }
        }
    }
        
#else


#endif

    
    /**
     * Creates a new Block
     * you can override this method to customize the properties
     */
    open func newBlock() -> Block {
        let block=Block()
        block.silentGroupedChanges {
            if let creator=self.metadata.currentUser {
                block.creatorUID = creator.UID
            }
            // Become managed
            self.blocks.add(block, commit:false)
        }
        block.commitRequired() // We defer the commit to allow to take account of overriden possible changes.
        return  block
    }

    /**
     * Creates a new Box
     * you can override this method to customize the properties
     */
    open func newBox() -> Box {
        let box=Box()
        box.silentGroupedChanges {
            if let creator=self.metadata.currentUser {
                box.creatorUID = creator.UID
            }
            // Become managed
            self.boxes.add(box, commit:false)
        }
        box.commitRequired() // We defer the commit to allow to take account of overriden possible changes.
        return  box
    }

    /**
     * Creates a new Locker
     * you can override this method to customize the properties
     */
    open func newLocker() -> Locker {
        let locker=Locker()
        locker.silentGroupedChanges {
            if let creator=self.metadata.currentUser {
                locker.creatorUID = creator.UID
            }
            // Become managed
            self.lockers.add(locker, commit:false)
        }
        locker.commitRequired() // We defer the commit to allow to take account of overriden possible changes.
        return  locker
    }

    /**
     * Creates a new Node
     * you can override this method to customize the properties
     */
    open func newNode() -> Node {
        let node=Node()
        node.silentGroupedChanges {
            if let creator=self.metadata.currentUser {
                node.creatorUID = creator.UID
            }
            // Become managed
            self.nodes.add(node, commit:false)
        }
        node.commitRequired() // We defer the commit to allow to take account of overriden possible changes.
        return  node
    }

}
