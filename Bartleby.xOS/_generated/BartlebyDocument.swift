//
//  BartlebyDocument.swift
//
//  The is the central piece of the Document oriented architecture.
//  We provide a universal implementation with conditionnal compilation
//
//  The document stores references to Bartleby's style CollectionControllers.
//  This allow to use intensively bindings and distributed data automation.
//  With the mediation of standard Bindings approach with NSArrayControler
//
//  We prefer to centralize the complexity of data handling in the document.
//  Thats why for example we implement projectBindingsArrayController.didSet with an CGD dispatching
//  We could have set the binding programmatically in the WindowController
//  But we consider for clarity that the Storyboarded Bindings Settings should be as exhaustive as possible.
//  And the potential complexity masked.
//
//  Generated by flexions
//

import Foundation

#if os(OSX)
import AppKit
#else
import UIKit
#endif

#if !USE_EMBEDDED_MODULES
import ObjectMapper
#endif



public class BartlebyDocument : Registry {

    #if os(OSX)

    required public init() {
        super.init()
        BartlebyDocument.declareTypes()
    }

    #else

    private var _fileURL: NSURL

    required public init(fileURL url: NSURL) {
        self._fileURL = url
        super.init(fileUrl: url)
        BartlebyDocument.declareTypes()
    }
    #endif


    // MARK  Universal Type Support

    override public class func declareTypes() {
        super.declareTypes()
    }


    // MARK: - Collection Controllers

    private var _KVOContext: Int = 0

    // The initial instances are proxies
    // On document deserialization the collection are populated.

	public dynamic var users=UsersCollectionController(){
		didSet{
			users.registry=self
		}
	}
	
	public dynamic var lockers=LockersCollectionController(){
		didSet{
			lockers.registry=self
		}
	}
	
	public dynamic var groups=GroupsCollectionController(){
		didSet{
			groups.registry=self
		}
	}
	
	public dynamic var operations=OperationsCollectionController(){
		didSet{
			operations.registry=self
		}
	}
	
	public dynamic var permissions=PermissionsCollectionController(){
		didSet{
			permissions.registry=self
		}
	}
	

    // MARK: - Array Controllers and automation (OSX)
 #if os(OSX) && !USE_EMBEDDED_MODULES


    // KVO
    // Those array controllers are Owned by their respective ViewControllers
    // Those view Controller are observed here to insure a consistent persitency


    public var usersArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            usersArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the CollectionController
            self.users.arrayController=usersArrayController
            // Add observer
            usersArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .New, context: &self._KVOContext)
            if let indexes=self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedUsersIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{indexesSet.addIndex($0)}
                self.usersArrayController?.setSelectionIndexes(indexesSet)
             }
        }
    }
        

    public var lockersArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            lockersArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the CollectionController
            self.lockers.arrayController=lockersArrayController
            // Add observer
            lockersArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .New, context: &self._KVOContext)
            if let indexes=self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedLockersIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{indexesSet.addIndex($0)}
                self.lockersArrayController?.setSelectionIndexes(indexesSet)
             }
        }
    }
        

    public var groupsArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            groupsArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the CollectionController
            self.groups.arrayController=groupsArrayController
            // Add observer
            groupsArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .New, context: &self._KVOContext)
            if let indexes=self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedGroupsIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{indexesSet.addIndex($0)}
                self.groupsArrayController?.setSelectionIndexes(indexesSet)
             }
        }
    }
        

    public var operationsArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            operationsArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the CollectionController
            self.operations.arrayController=operationsArrayController
            // Add observer
            operationsArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .New, context: &self._KVOContext)
            if let indexes=self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedOperationsIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{indexesSet.addIndex($0)}
                self.operationsArrayController?.setSelectionIndexes(indexesSet)
             }
        }
    }
        

    public var permissionsArrayController: NSArrayController?{
        willSet{
            // Remove observer on previous array Controller
            permissionsArrayController?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the CollectionController
            self.permissions.arrayController=permissionsArrayController
            // Add observer
            permissionsArrayController?.addObserver(self, forKeyPath: "selectionIndexes", options: .New, context: &self._KVOContext)
            if let indexes=self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedPermissionsIndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{indexesSet.addIndex($0)}
                self.permissionsArrayController?.setSelectionIndexes(indexesSet)
             }
        }
    }
        



#endif

    // indexes persistency

    
    static public let kSelectedUsersIndexesKey="selectedUsersIndexesKey"
    static public let USERS_SELECTED_INDEXES_CHANGED_NOTIFICATION="USERS_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic public var selectedUsers:[User]?{
        didSet{
            if let users = selectedUsers {
                 let indexes:[Int]=users.map({ (user) -> Int in
                    return self.users.indexOf( { return $0.UID == user.UID })!
                })
                self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedUsersIndexesKey]=indexes
                NSNotificationCenter.defaultCenter().postNotificationName(BartlebyDocument.USERS_SELECTED_INDEXES_CHANGED_NOTIFICATION, object: nil)
            }
        }
    }
    var firstSelectedUser:User? { return self.selectedUsers?.first }
        
        

    
    static public let kSelectedLockersIndexesKey="selectedLockersIndexesKey"
    static public let LOCKERS_SELECTED_INDEXES_CHANGED_NOTIFICATION="LOCKERS_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic public var selectedLockers:[Locker]?{
        didSet{
            if let lockers = selectedLockers {
                 let indexes:[Int]=lockers.map({ (locker) -> Int in
                    return self.lockers.indexOf( { return $0.UID == locker.UID })!
                })
                self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedLockersIndexesKey]=indexes
                NSNotificationCenter.defaultCenter().postNotificationName(BartlebyDocument.LOCKERS_SELECTED_INDEXES_CHANGED_NOTIFICATION, object: nil)
            }
        }
    }
    var firstSelectedLocker:Locker? { return self.selectedLockers?.first }
        
        

    
    static public let kSelectedGroupsIndexesKey="selectedGroupsIndexesKey"
    static public let GROUPS_SELECTED_INDEXES_CHANGED_NOTIFICATION="GROUPS_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic public var selectedGroups:[Group]?{
        didSet{
            if let groups = selectedGroups {
                 let indexes:[Int]=groups.map({ (group) -> Int in
                    return self.groups.indexOf( { return $0.UID == group.UID })!
                })
                self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedGroupsIndexesKey]=indexes
                NSNotificationCenter.defaultCenter().postNotificationName(BartlebyDocument.GROUPS_SELECTED_INDEXES_CHANGED_NOTIFICATION, object: nil)
            }
        }
    }
    var firstSelectedGroup:Group? { return self.selectedGroups?.first }
        
        

    
    static public let kSelectedOperationsIndexesKey="selectedOperationsIndexesKey"
    static public let OPERATIONS_SELECTED_INDEXES_CHANGED_NOTIFICATION="OPERATIONS_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic public var selectedOperations:[Operation]?{
        didSet{
            if let operations = selectedOperations {
                 let indexes:[Int]=operations.map({ (operation) -> Int in
                    return self.operations.indexOf( { return $0.UID == operation.UID })!
                })
                self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedOperationsIndexesKey]=indexes
                NSNotificationCenter.defaultCenter().postNotificationName(BartlebyDocument.OPERATIONS_SELECTED_INDEXES_CHANGED_NOTIFICATION, object: nil)
            }
        }
    }
    var firstSelectedOperation:Operation? { return self.selectedOperations?.first }
        
        

    
    static public let kSelectedPermissionsIndexesKey="selectedPermissionsIndexesKey"
    static public let PERMISSIONS_SELECTED_INDEXES_CHANGED_NOTIFICATION="PERMISSIONS_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic public var selectedPermissions:[Permission]?{
        didSet{
            if let permissions = selectedPermissions {
                 let indexes:[Int]=permissions.map({ (permission) -> Int in
                    return self.permissions.indexOf( { return $0.UID == permission.UID })!
                })
                self.registryMetadata.stateDictionary[BartlebyDocument.kSelectedPermissionsIndexesKey]=indexes
                NSNotificationCenter.defaultCenter().postNotificationName(BartlebyDocument.PERMISSIONS_SELECTED_INDEXES_CHANGED_NOTIFICATION, object: nil)
            }
        }
    }
    var firstSelectedPermission:Permission? { return self.selectedPermissions?.first }
        
        




    // MARK: - Schemas

    /**

    In this func you should :

    #1  Define the Schema
    #2  Register the collections

    */
    override public func configureSchema(){

        // #1  Defines the Schema
        super.configureSchema()

        let userDefinition = CollectionMetadatum()
        userDefinition.proxy = self.users
        // By default we group the observation via the rootObjectUID
        userDefinition.collectionName = User.collectionName
        userDefinition.storage = CollectionMetadatum.Storage.MonolithicFileStorage
        userDefinition.allowDistantPersistency = true
        userDefinition.inMemory = false
        

        let lockerDefinition = CollectionMetadatum()
        lockerDefinition.proxy = self.lockers
        // By default we group the observation via the rootObjectUID
        lockerDefinition.collectionName = Locker.collectionName
        lockerDefinition.storage = CollectionMetadatum.Storage.MonolithicFileStorage
        lockerDefinition.allowDistantPersistency = true
        lockerDefinition.inMemory = false
        

        let groupDefinition = CollectionMetadatum()
        groupDefinition.proxy = self.groups
        // By default we group the observation via the rootObjectUID
        groupDefinition.collectionName = Group.collectionName
        groupDefinition.storage = CollectionMetadatum.Storage.MonolithicFileStorage
        groupDefinition.allowDistantPersistency = true
        groupDefinition.inMemory = false
        

        let operationDefinition = CollectionMetadatum()
        operationDefinition.proxy = self.operations
        // By default we group the observation via the rootObjectUID
        operationDefinition.collectionName = Operation.collectionName
        operationDefinition.storage = CollectionMetadatum.Storage.MonolithicFileStorage
        operationDefinition.allowDistantPersistency = false
        operationDefinition.inMemory = false
        

        let permissionDefinition = CollectionMetadatum()
        permissionDefinition.proxy = self.permissions
        // By default we group the observation via the rootObjectUID
        permissionDefinition.collectionName = Permission.collectionName
        permissionDefinition.storage = CollectionMetadatum.Storage.MonolithicFileStorage
        permissionDefinition.allowDistantPersistency = true
        permissionDefinition.inMemory = false
        


        // Proceed to configuration
        do{

			try self.registryMetadata.configureSchema(userDefinition)
			try self.registryMetadata.configureSchema(lockerDefinition)
			try self.registryMetadata.configureSchema(groupDefinition)
			try self.registryMetadata.configureSchema(operationDefinition)
			try self.registryMetadata.configureSchema(permissionDefinition)

        }catch RegistryError.DuplicatedCollectionName(let collectionName){
            bprint("Multiple Attempt to add the Collection named \(collectionName)",file:#file,function:#function,line:#line)
        }catch {
            bprint("\(error)",file:#file,function:#function,line:#line)
        }

        // #2 Registers the collections
        do{
            try self.registerCollections()
        }catch{
        }
    }

    // MARK: - OSX specific

 #if os(OSX) && !USE_EMBEDDED_MODULES

    // MARK: KVO

    override public func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer<Void>) {
        guard context == &_KVOContext else {
            // If the context does not match, this message
            // must be intended for our superclass.
            super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)
            return
        }

        // We prefer to centralize the KVO for selection indexes at the top level
        if let keyPath = keyPath, object = object {

                    
            if keyPath=="selectionIndexes" && self.usersArrayController == object as? NSArrayController {
                if let users = self.usersArrayController?.selectedObjects as? [User] {
                     if let selectedUser = self.selectedUsers{
                        if selectedUser == users{
                            return // No changes
                        }
                     }
                    self.selectedUsers=users
                }
                return
            }
            

            
            if keyPath=="selectionIndexes" && self.lockersArrayController == object as? NSArrayController {
                if let lockers = self.lockersArrayController?.selectedObjects as? [Locker] {
                     if let selectedLocker = self.selectedLockers{
                        if selectedLocker == lockers{
                            return // No changes
                        }
                     }
                    self.selectedLockers=lockers
                }
                return
            }
            

            
            if keyPath=="selectionIndexes" && self.groupsArrayController == object as? NSArrayController {
                if let groups = self.groupsArrayController?.selectedObjects as? [Group] {
                     if let selectedGroup = self.selectedGroups{
                        if selectedGroup == groups{
                            return // No changes
                        }
                     }
                    self.selectedGroups=groups
                }
                return
            }
            

            
            if keyPath=="selectionIndexes" && self.operationsArrayController == object as? NSArrayController {
                if let operations = self.operationsArrayController?.selectedObjects as? [Operation] {
                     if let selectedOperation = self.selectedOperations{
                        if selectedOperation == operations{
                            return // No changes
                        }
                     }
                    self.selectedOperations=operations
                }
                return
            }
            

            
            if keyPath=="selectionIndexes" && self.permissionsArrayController == object as? NSArrayController {
                if let permissions = self.permissionsArrayController?.selectedObjects as? [Permission] {
                     if let selectedPermission = self.selectedPermissions{
                        if selectedPermission == permissions{
                            return // No changes
                        }
                     }
                    self.selectedPermissions=permissions
                }
                return
            }
            

        }

    }

    // MARK:  Delete currently selected items
    
    public func deleteSelectedUsers() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedUsers{
            for item in selected{
                 self.users.removeObject(item, commit:true)
            }
        }
    }
        

    public func deleteSelectedLockers() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedLockers{
            for item in selected{
                 self.lockers.removeObject(item, commit:true)
            }
        }
    }
        

    public func deleteSelectedGroups() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedGroups{
            for item in selected{
                 self.groups.removeObject(item, commit:true)
            }
        }
    }
        

    public func deleteSelectedOperations() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedOperations{
            for item in selected{
                 self.operations.removeObject(item, commit:true)
            }
        }
    }
        

    public func deleteSelectedPermissions() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selectedPermissions{
            for item in selected{
                 self.permissions.removeObject(item, commit:true)
            }
        }
    }
        


    #else


    #endif

    
    // MARK : new User facility 
    
    /**
    * Creates a new user
    * 
    * you should override this method to customize default (name, email, ...)
    * and call before returning :
    *   if(user.creatorUID != user.UID){
    *       // We don't want to add the current user to user list
    *       self.users.add(user, commit:true)
    *   }
    */
    public func newUser() -> User {
        let user=User()
        if let creator=self.registryMetadata.currentUser {
            user.creatorUID = creator.UID
        }else{
            // Autopoiesis.
            user.creatorUID = user.UID
        }
        user.spaceUID = self.registryMetadata.spaceUID
        user.document = self // Very important for the  document registry metadata current User
        return user
    }
       
     
    // MARK: - Synchronization


    // The EventSource URL for Server Sent Events
    public dynamic lazy var sseURL:NSURL=NSURL(string: self.baseURL.absoluteString+"/SSETriggers?spaceUID=\(self.spaceUID)&observationUID=\(self.UID)&lastIndex=\(self.registryMetadata.lastIntegratedTriggerIndex)&runUID=\(Bartleby.runUID)&showDetails=false")!


    // The online flag is driving the "connection" process
    // It connects to the SSE and starts the supervisionLoop
    public var online:Bool=false{
        willSet{
            // Transition on line
            if newValue==true && online==false{
                self._connectToSSE()
            }
            // Transition off line
            if newValue==false && online==true{
                bprint("SSE is transitioning offline",file:#file,function:#function,line:#line,category: "SSE")
                self._closeSSE()
            }
            if newValue==online{
                bprint("Neutral online var setting",file:#file,function:#function,line:#line,category: "SSE")
            }
        }
        didSet{
            self.registryMetadata.online=online
            self.startSupervisionLoopIfNecessary()
        }
    }

    public var synchronizationHandlers:Handlers=Handlers.withoutCompletion()

    internal var _timer:NSTimer?


    // MARK: SSE

    // SSE server sent event source
    internal var _sse:EventSource?

    /**
     Connect to SSE
     */
    internal func _connectToSSE() {
        bprint("SSE is transitioning online",file:#file,function:#function,line:#line,category: "SSE")
        // The connection is restricted to identified users
        // `PERMISSION_BY_IDENTIFICATION` the current user must be in the dataspace.
        LoginUser.execute(self.currentUser, withPassword: self.currentUser.password, sucessHandler: {

            let headers=HTTPManager.httpHeadersWithToken(inRegistryWithUID: self.UID, withActionName: "SSETriggers")
            self._sse=EventSource(url:self.sseURL.absoluteString,headers:headers)

            bprint("Creating the event source instance: \(self.sseURL)",file:#file,function:#function,line:#line,category: "SSE")

            self._sse!.addEventListener("relay") { (id, event, data) in
                bprint("\(id) \(event) \(data)",file:#file,function:#function,line:#line,category: "SSE")

                // Parse the Data

                /*

                 ```
                 id: 1466684879     <- the Event ID
                 event: relay       <- the Event Name
                 data: {            <- the data

                 "i":1,                                                     <- the trigger index
                 "o":"MkY2NzA4MUYtRDFGQi00Qjk0LTgyNzctNDUwQThDRjZGMDU3",    <- The observation UID
                 "r":"MzY5MDA4OTYtMDUxNS00MzdFLTgzOEEtNTQ1QjU4RDc4MEY3",    <- The run UID
                 "s":"RjQ0QjU0NDMtMjE4OC00NEZBLUFFODgtRTA1MzlGN0FFMTVE",    <- The sender UID
                 "c":"users",                                               <- The collection name
                 "n":"CreateUser",                                          <- origin   : The action that have originated the trigger (optionnal)
                 "a":"ReadUserbyId",                                        <- action   : The action to be triggered
                 "u":"RjQ0QjU0NDMtMjE4OC00NEZBLUFFODgtRTA1MzlGN0FFMTVE"     <- the uids : The concerned UIDS

                 ```

                 */
                do {
                    if let dataFromString=data?.dataUsingEncoding(NSUTF8StringEncoding){
                        if let JSONDictionary = try NSJSONSerialization.JSONObjectWithData(dataFromString, options:NSJSONReadingOptions.AllowFragments) as? [String:AnyObject] {
                            if  let index:Int=JSONDictionary["i"] as? Int,
                                let observationUID:String=JSONDictionary["o"] as? String,
                                let action:String=JSONDictionary["a"] as? String,
                                let collectionName=JSONDictionary["c"] as? String,
                                let uids=JSONDictionary["u"] as? String {

                                let trigger=Trigger()
                                trigger.spaceUID=self.spaceUID

                                // Mandatory Trigger Data
                                trigger.index=index
                                trigger.observationUID=observationUID
                                trigger.action=action
                                trigger.targetCollectionName=collectionName
                                trigger.UIDS=uids

                                // Optional data
                                // That may be omitted on triggering

                                trigger.runUID=JSONDictionary["r"] as? String
                                trigger.senderUID=JSONDictionary["s"] as? String
                                trigger.origin=JSONDictionary["n"] as? String


                                var triggers=[Trigger]()
                                triggers.append(trigger)
                                // Uses BartlebyDocument+Triggers extension.
                                self._triggersHasBeenReceived(triggers)


                            }
                        }
                    }

                }catch{
                    bprint("Exception \(error) on \(id) \(event) \(data)",file:#file,function:#function,line:#line,category: "SSE")
                }
            }

        }) { (context) in
            bprint("Login failed \(context)",file:#file,function:#function,line:#line,category: "SSE")
            self.registryMetadata.online=false
        }

    }

    /**
     Closes the Server sent EventSource
     */
    internal func _closeSSE() {
        if let sse=self._sse{
            sse.close()
            self._sse=nil
        }
    }

    // MARK: triggered data buffer serialization support

    // To insure persistency of non integrated data.

    private func _dataFrom_triggeredDataBuffer()->NSData?{
        // We use a super dictionary to store the Trigger as JSON as key
        // and the collectible items as value
        var superDictionary=[String:[[String : AnyObject]]]()
        for (trigger,dictionary) in self._triggeredDataBuffer{
            if let k=trigger.toJSONString(){
                superDictionary[k]=dictionary
            }
        }
        do{
            let data = try NSJSONSerialization.dataWithJSONObject(superDictionary, options:[])
            return data
        }catch{
            bprint("Serialization exception \(error)", file: #file, function: #function, line: #line, category: bprintCategoryFor(Trigger), decorative: false)
            return nil
        }
    }

    private func _setUp_triggeredDataBuffer(from:NSData?){
        if let data=from{
            do{
                if let superDictionary:[String:[[String : AnyObject]]] = try NSJSONSerialization.JSONObjectWithData(data, options: .AllowFragments) as? [String:[[String : AnyObject]]]{
                    for (jsonTrigger,dictionary) in superDictionary{
                        if let trigger:Trigger = Mapper<Trigger>().map(jsonTrigger){
                            self._triggeredDataBuffer[trigger]=dictionary
                        }else{
                            bprint("Trigger json mapping issue \(jsonTrigger)", file: #file, function: #function, line: #line, category: bprintCategoryFor(Trigger), decorative: false)
                        }
                    }
                }
            }catch{
                bprint("Deserialization exception \(error)", file: #file, function: #function, line: #line, category: bprintCategoryFor(Trigger), decorative: false)
            }
        }
    }

    /**

     - returns: a bunch information on the current Buffer.
     */
    public func getTriggerBufferInformations()->String{

        var informations="#Triggers to be integrated \(self._triggeredDataBuffer.count)\n"

        // Data buffer
        for (trigger,dictionary) in self._triggeredDataBuffer {
            let s = try?NSJSONSerialization.dataWithJSONObject(dictionary, options: [])
            let n = (s?.length ?? 0)
            informations += "\(trigger.index) \(trigger.action) \(trigger.origin ?? "" ) \(trigger.UIDS)  \(n)\n"
        }

        // Missing
        let missing=self.missingContiguousTriggersIndexes()
        informations += missing.reduce("Missing indexes (\(missing.count)): ", combine: { (string, index) -> String in
            return "\(string) \(index)"
        })
        informations += "\n"

        // TriggerIndexes
        let triggersIndexes=self.registryMetadata.triggersIndexes

        informations += "Trigger Indexes (\(triggersIndexes.count)): "
        informations += triggersIndexes.reduce("", combine: { (string, index) -> String in
            return "\(string) \(index)"
        })
        informations += "\n"

        // Owned Indexes
        let ownedTriggersIndexes=self.registryMetadata.ownedTriggersIndexes

        informations += "Owned Indexes (\(ownedTriggersIndexes.count)): "
        informations += ownedTriggersIndexes.reduce("", combine: { (string, index) -> String in
            return "\(string) \(index)"
        })
        informations += "\n"
        informations += "Last integrated trigger Index = \(self.registryMetadata.lastIntegratedTriggerIndex)\n"


        return informations
    }




    // MARK: - Local Persistency

    #if os(OSX)


    // MARK:  NSDocument

    // MARK: Serialization
    override public func fileWrapperOfType(typeName: String) throws -> NSFileWrapper {

        self.registryWillSave()
        let fileWrapper=NSFileWrapper(directoryWithFileWrappers:[:])
        if var fileWrappers=fileWrapper.fileWrappers {

            // ##############
            // #1 Metadata
            // ##############

            // Try to store a preferred filename
            self.registryMetadata.preferredFileName=self.fileURL?.lastPathComponent
            // Save the triggered Data Buffer
            self.registryMetadata.triggeredDataBuffer=self._dataFrom_triggeredDataBuffer()
            var metadataNSData=self.registryMetadata.serialize()

            metadataNSData = try Bartleby.cryptoDelegate.encryptData(metadataNSData)

            // Remove the previous metadata
            if let wrapper=fileWrappers[self._metadataFileName] {
                fileWrapper.removeFileWrapper(wrapper)
            }
            let metadataFileWrapper=NSFileWrapper(regularFileWithContents: metadataNSData)
            metadataFileWrapper.preferredFilename=self._metadataFileName
            fileWrapper.addFileWrapper(metadataFileWrapper)

            // ##############
            // #2 Collections
            // ##############

            for metadatum: CollectionMetadatum in self.registryMetadata.collectionsMetadata {

                if !metadatum.inMemory {
                    let collectionfileName=self._collectionFileNames(metadatum).crypted
                    // MONOLITHIC STORAGE
                    if metadatum.storage == CollectionMetadatum.Storage.MonolithicFileStorage {

                        if let collection = self.collectionByName(metadatum.collectionName) as? CollectibleCollection {

                            // We use multiple files

                            var collectionData = collection.serialize()
                            collectionData = try Bartleby.cryptoDelegate.encryptData(collectionData)

                            // Remove the previous data
                            if let wrapper=fileWrappers[collectionfileName] {
                                fileWrapper.removeFileWrapper(wrapper)
                            }

                            let collectionFileWrapper=NSFileWrapper(regularFileWithContents: collectionData)
                            collectionFileWrapper.preferredFilename=collectionfileName
                            fileWrapper.addFileWrapper(collectionFileWrapper)
                        } else {
                            // NO COLLECTION
                        }
                    } else {
                        // SQLITE
                    }

                }
            }


            // Stores the last logs in a file.

            self._logs += "{\"runUID\":\"\(Bartleby.runUID)\",\"date\":\"\(NSDate())\"}\(Bartleby.logSectionSeparator)"
            self._logs += Bartleby.bprintCollection.toJSONString() ?? ""
            let logs=NSFileWrapper(regularFileWithContents: self._logs.dataUsingEncoding(NSUTF8StringEncoding)!)
            logs.preferredFilename=self._logsFileName
            fileWrapper.addFileWrapper(logs)


        }
        return fileWrapper
    }

    // MARK: Deserialization


    /**
     Standard Bundles loading

     - parameter fileWrapper: the file wrapper
     - parameter typeName:    the type name

     - throws: misc exceptions
     */
    override public func readFromFileWrapper(fileWrapper: NSFileWrapper, ofType typeName: String) throws {
        if let fileWrappers=fileWrapper.fileWrappers {

            // ##############
            // #1 Metadata
            // ##############

            if let wrapper=fileWrappers[_metadataFileName] {
                if var metadataNSData=wrapper.regularFileContents {
                    metadataNSData = try Bartleby.cryptoDelegate.decryptData(metadataNSData)
                    let r = try Bartleby.defaultSerializer.deserialize(metadataNSData)
                    if let registryMetadata=r as? RegistryMetadata {
                        self.registryMetadata=registryMetadata
                    } else {
                        // There is an error
                        bprint("ERROR \(r)", file: #file, function: #function, line: #line)
                        return
                    }
                    let registryUID=self.registryMetadata.rootObjectUID
                    Bartleby.sharedInstance.replaceRegistryUID(Default.NO_UID, by: registryUID)
                    self.registryMetadata.currentUser?.document=self

                    // Setup the triggered data buffer
                    self._setUp_triggeredDataBuffer(self.registryMetadata.triggeredDataBuffer)
                }
            } else {
                // ERROR
            }


            // ##############
            // #2 Collections
            // ##############

            for metadatum in self.registryMetadata.collectionsMetadata {
                // MONOLITHIC STORAGE
                if metadatum.storage == CollectionMetadatum.Storage.MonolithicFileStorage {
                    let names=self._collectionFileNames(metadatum)
                    if let wrapper=fileWrappers[names.crypted] ?? fileWrappers[names.notCrypted] {
                        let filename=wrapper.filename
                        if var collectionData=wrapper.regularFileContents {
                            if let proxy=self.collectionByName(metadatum.collectionName) {
                                if let path: NSString=filename {
                                    let pathExtension="."+path.pathExtension
                                    if  pathExtension == Registry.DATA_EXTENSION {
                                        collectionData = try Bartleby.cryptoDelegate.decryptData(collectionData)
                                    }
                                    try proxy.updateData(collectionData,provisionChanges: false)
                                }
                            } else {
                                throw RegistryError.AttemptToLoadAnNonSupportedCollection(collectionName:metadatum.d_collectionName)
                            }
                        }
                    } else {
                        // ERROR
                    }
                } else {
                    // SQLite
                }
            }
            do {
                try self._refreshProxies()
            } catch {
                bprint("Proxies refreshing failure \(error)", file: #file, function: #function, line: #line)
            }
            
            // 3 Logs
            
            if let wrapper=fileWrappers[self._logsFileName] {
                if let logsData=wrapper.regularFileContents {
                    self._logs=String(data: logsData,encoding: NSUTF8StringEncoding) ?? ""
                }
            } else {
                // ERROR
            }
            
            dispatch_async(GlobalQueue.Main.get(), {
                self.registryDidLoad()
            })
        }
    }
    
    #else
    
    
    // MARK: iOS UIDocument serialization / deserialization
    
    // TODO: @bpds(#IOS) UIDocument support
    
    // SAVE content
    override public func contentsForType(typeName: String) throws -> AnyObject {
    return ""
    }
    
    // READ content
    override public func loadFromContents(contents: AnyObject, ofType typeName: String?) throws {
    
    }
    
    #endif  
         
        

}
