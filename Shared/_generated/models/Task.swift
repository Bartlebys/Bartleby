//
//  Task.swift
//  Bartleby
//
// THIS FILE AS BEEN GENERATED BY BARTLEBYFLEXIONS for benoit@pereira-da-silva.com
// DO NOT MODIFY THIS FILE YOUR MODIFICATIONS WOULD BE ERASED ON NEXT GENERATION!
// WE TRY TO GENERATE ANY REPETITIVE CODE AND TO IMPROVE THE QUALITY ITERATIVELY
//
// Copyright (c) 2015  Chaosmos | https://chaosmos.fr  All rights reserved.
//
import Foundation
#if !USE_EMBEDDED_MODULES
import Alamofire
import ObjectMapper
#endif

// MARK: Model Task
@objc(Task) public class Task : BaseObject{


	//Task Status
	public enum Status:String{
		case New = "new"
		case Pending = "pending"
		case Running = "running"
		case Suspended = "suspended"
		case Completed = "completed"
	}
	public var status:Status = .New
	//The priority is equal to the parent task.
	public enum Priority:String{
		case Background = "Background"
		case Low = "Low"
		case Default = "Default"
		case High = "High"
	}
	public var priority:Priority = .Default
	//The parent task
	public var parent:Task?
	//The failure task (can be used to cleanup or notify failure)
	public var onFailure:Task?
	//A collection of Concrete Tasks
	public var children:[Task] = [Task]()
	//The progression state of the task
	public var progressionState:Progression = Progression()
	//The completion state of the task
	public var completionState:Completion = Completion()
	//The serialized arguments
	public var argumentsData:NSData?
	//The serialized result
	public var resultData:NSData?
	//The task class name
	public var taskClassName:String?
	//The argument class name
	public var argumentClassName:String?


    // MARK: Mappable

    required public init?(_ map: Map) {
        super.init(map)
        mapping(map)
    }

    override public func mapping(map: Map) {
        super.mapping(map)
		status <- map["status"]
		priority <- map["priority"]
		parent <- map["parent"]
		onFailure <- map["onFailure"]
		children <- map["children"]
		progressionState <- map["progressionState"]
		completionState <- map["completionState"]
		argumentsData <- (map["argumentsData"],Base64DataTransform())
		resultData <- (map["resultData"],Base64DataTransform())
		taskClassName <- map["taskClassName"]
		argumentClassName <- map["argumentClassName"]
    }


    // MARK: NSSecureCoding

    required public init?(coder decoder: NSCoder) {
        super.init(coder: decoder)
		status=Task.Status(rawValue:String(decoder.decodeObjectOfClass(NSString.self, forKey: "status")! as NSString))! 
		priority=Task.Priority(rawValue:String(decoder.decodeObjectOfClass(NSString.self, forKey: "priority")! as NSString))! 
		parent=decoder.decodeObjectOfClass(Task.self, forKey: "parent") 
		onFailure=decoder.decodeObjectOfClass(Task.self, forKey: "onFailure") 
		children=decoder.decodeObjectOfClasses(NSSet(array: [NSArray.classForCoder(),Task.classForCoder()]), forKey: "children")! as! [Task]
		progressionState=decoder.decodeObjectOfClass(Progression.self, forKey: "progressionState")! 
		completionState=decoder.decodeObjectOfClass(Completion.self, forKey: "completionState")! 
		argumentsData=decoder.decodeObjectOfClass(NSData.self, forKey:"argumentsData") as NSData?
		resultData=decoder.decodeObjectOfClass(NSData.self, forKey:"resultData") as NSData?
		taskClassName=String(decoder.decodeObjectOfClass(NSString.self, forKey:"taskClassName") as NSString?)
		argumentClassName=String(decoder.decodeObjectOfClass(NSString.self, forKey:"argumentClassName") as NSString?)

    }

    override public func encodeWithCoder(coder: NSCoder) {
        super.encodeWithCoder(coder)
		coder.encodeObject(status.rawValue ,forKey:"status")
		coder.encodeObject(priority.rawValue ,forKey:"priority")
		if let parent = self.parent {
			coder.encodeObject(parent,forKey:"parent")
		}
		if let onFailure = self.onFailure {
			coder.encodeObject(onFailure,forKey:"onFailure")
		}
		coder.encodeObject(children,forKey:"children")
		coder.encodeObject(progressionState,forKey:"progressionState")
		coder.encodeObject(completionState,forKey:"completionState")
		if let argumentsData = self.argumentsData {
			coder.encodeObject(argumentsData,forKey:"argumentsData")
		}
		if let resultData = self.resultData {
			coder.encodeObject(resultData,forKey:"resultData")
		}
		if let taskClassName = self.taskClassName {
			coder.encodeObject(taskClassName,forKey:"taskClassName")
		}
		if let argumentClassName = self.argumentClassName {
			coder.encodeObject(argumentClassName,forKey:"argumentClassName")
		}
    }


    override public class func supportsSecureCoding() -> Bool{
        return true
    }


    required public init() {
        super.init()
    }

    // MARK: Identifiable

    override public class var collectionName:String{
        return "tasks"
    }

    override public var d_collectionName:String{
        return Task.collectionName
    }


    // MARK: Persistent

    override public func toPersistentRepresentation()->(UID:String,collectionName:String,serializedUTF8String:String,A:Double,B:Double,C:Double,D:Double,E:Double,S:String){
        var r=super.toPersistentRepresentation()
        r.A=NSDate().timeIntervalSince1970
        return r
    }

}

