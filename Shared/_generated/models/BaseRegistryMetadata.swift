//
//  BaseRegistryMetadata.swift
//  Bartleby
//
// THIS FILE AS BEEN GENERATED BY BARTLEBYFLEXIONS for benoit@pereira-da-silva.com
// DO NOT MODIFY THIS FILE YOUR MODIFICATIONS WOULD BE ERASED ON NEXT GENERATION!
// WE TRY TO GENERATE ANY REPETITIVE CODE AND TO IMPROVE THE QUALITY ITERATIVELY
//
// Copyright (c) 2015  Chaosmos | https://chaosmos.fr  All rights reserved.
//
import Foundation
#if !USE_EMBEDDED_MODULES
import Alamofire
import ObjectMapper
#endif

// MARK: Model BaseRegistryMetadata
@objc(BaseRegistryMetadata) public class BaseRegistryMetadata : BaseObject{


	//The data space UID can be shared between multiple registries.
	dynamic public var spaceUID:String = "\(Default.NO_UID)"
	//The root user of the registry is the user currently associated to the local instance of the registry
	public var rootUser:User?
	//The rootObject UID
	dynamic public var rootObjectUID:String = "\(Default.NO_UID)"
	//The url of the collaboration server
	dynamic public var collaborationServerURL:NSURL?
	//A collection of CollectionMetadatum
	public var collectionsMetadata:[JCollectionMetadatum] = [JCollectionMetadatum]()
	//The State dictionary to insure registry persistency 
	public var stateDictionary:Dictionary<String, AnyObject> = [String:AnyObject]()
	//The collection of serialized Security-Scoped Bookmarks (you should store NSData)
	public var URLBookmarkData:Dictionary<String, AnyObject> = [String:AnyObject]()
	//Save the password or not?
	dynamic public var saveThePassword:Bool = Bartleby.configuration.SAVE_PASSWORD_DEFAULT_VALUE
	//The url of the assets folder
	dynamic public var assetsFolderURL:NSURL?


    // MARK: Mappable

    required public init?(_ map: Map) {
        super.init(map)
        mapping(map)
    }

    override public func mapping(map: Map) {
        super.mapping(map)
		spaceUID <- map["spaceUID"]
		rootUser <- map["rootUser"]
		rootObjectUID <- map["rootObjectUID"]
		collaborationServerURL <- (map["collaborationServerURL"],URLTransform())
		collectionsMetadata <- map["collectionsMetadata"]
		stateDictionary <- map["stateDictionary"]
		URLBookmarkData <- map["URLBookmarkData"]
		saveThePassword <- map["saveThePassword"]
		assetsFolderURL <- (map["assetsFolderURL"],URLTransform())
    }


    // MARK: NSSecureCoding

    required public init?(coder decoder: NSCoder) {
        super.init(coder: decoder)
		spaceUID=String(decoder.decodeObjectOfClass(NSString.self, forKey: "spaceUID")! as NSString)
		rootUser=decoder.decodeObjectOfClass(User.self, forKey: "rootUser") 
		rootObjectUID=String(decoder.decodeObjectOfClass(NSString.self, forKey: "rootObjectUID")! as NSString)
		collaborationServerURL=decoder.decodeObjectOfClass(NSURL.self, forKey:"collaborationServerURL") as NSURL?
		collectionsMetadata=decoder.decodeObjectOfClasses(NSSet(array: [NSArray.classForCoder(),JCollectionMetadatum.classForCoder()]), forKey: "collectionsMetadata")! as! [JCollectionMetadatum]
		stateDictionary=decoder.decodeObjectOfClasses(NSSet(array: [NSDictionary.classForCoder(),NSString.classForCoder(),NSNumber.classForCoder(),NSObject.classForCoder(),NSSet.classForCoder()]), forKey: "stateDictionary")as! Dictionary<String, AnyObject>
		URLBookmarkData=decoder.decodeObjectOfClasses(NSSet(array: [NSDictionary.classForCoder(),NSString.classForCoder(),NSNumber.classForCoder(),NSObject.classForCoder(),NSSet.classForCoder()]), forKey: "URLBookmarkData")as! Dictionary<String, AnyObject>
		saveThePassword=decoder.decodeBoolForKey("saveThePassword") 
		assetsFolderURL=decoder.decodeObjectOfClass(NSURL.self, forKey:"assetsFolderURL") as NSURL?

    }

    override public func encodeWithCoder(coder: NSCoder) {
        super.encodeWithCoder(coder)
		coder.encodeObject(spaceUID,forKey:"spaceUID")
		if let rootUser = self.rootUser {
			coder.encodeObject(rootUser,forKey:"rootUser")
		}
		coder.encodeObject(rootObjectUID,forKey:"rootObjectUID")
		if let collaborationServerURL = self.collaborationServerURL {
			coder.encodeObject(collaborationServerURL,forKey:"collaborationServerURL")
		}
		coder.encodeObject(collectionsMetadata,forKey:"collectionsMetadata")
		coder.encodeObject(stateDictionary,forKey:"stateDictionary")
		coder.encodeObject(URLBookmarkData,forKey:"URLBookmarkData")
		coder.encodeBool(saveThePassword,forKey:"saveThePassword")
		if let assetsFolderURL = self.assetsFolderURL {
			coder.encodeObject(assetsFolderURL,forKey:"assetsFolderURL")
		}
    }


    override public class func supportsSecureCoding() -> Bool{
        return true
    }


    required public init() {
        super.init()
    }

    // MARK: Identifiable

    override public class var collectionName:String{
        return "baseRegistryMetadatas"
    }

    override public var d_collectionName:String{
        return BaseRegistryMetadata.collectionName
    }


    // MARK: Persistent

    override public func toPersistentRepresentation()->(UID:String,collectionName:String,serializedUTF8String:String,A:Double,B:Double,C:Double,D:Double,E:Double,S:String){
        var r=super.toPersistentRepresentation()
        r.A=NSDate().timeIntervalSince1970
        return r
    }

}

