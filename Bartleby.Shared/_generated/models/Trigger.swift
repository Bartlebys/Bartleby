//
//  Trigger.swift
//  Bartleby
//
// THIS FILE AS BEEN GENERATED BY BARTLEBYFLEXIONS for b@bartlebys.org
// DO NOT MODIFY THIS FILE YOUR MODIFICATIONS WOULD BE ERASED ON NEXT GENERATION!
//
// Copyright (c) 2016  Bartleby's | https://bartlebys.org  All rights reserved.
//
import Foundation
#if !USE_EMBEDDED_MODULES
import Alamofire
import ObjectMapper
#endif

// MARK: Bartleby's Core: a Trigger encapsulates a bunch of ExternalReferencees that's modelizes a state transformation
@objc(Trigger) public class Trigger : JObject{

    // Universal type support
    override public class func typeName() -> String {
        return "Trigger"
    }

	//The index is injected server side (each dataspace-registry) has it own counter)
	public var index:Int = -1
	//The dataSpace UID
	public var spaceUID:String?
	//The observation UID for a given document correspond  to the Registry.rootObjectUID
	public var observationUID:String?
	//The user.UID of the sender
	public var senderUID:String?
	//The UID of the instance of Bartleby client that has created the trigger.
	public var runUID:String?
	//The action that has initiated the trigger
	public var origin:String?
	//The targetted collection name
	public var targetCollectionName:String = ""
	//The server side creation date ( informative, use index for ranking)
	public var creationDate:NSDate?
	//The action name
	public var action:String = ""
	//A coma separated UIDS list
	public var UIDS:String = ""


    // MARK: Mappable

    required public init?(_ map: Map) {
        super.init(map)
    }

    override public func mapping(map: Map) {
        super.mapping(map)
        self.disableSupervision()
        self.disableAutoCommit()
		self.index <- ( map["index"] )
		self.spaceUID <- ( map["spaceUID"] )
		self.observationUID <- ( map["observationUID"] )
		self.senderUID <- ( map["senderUID"] )
		self.runUID <- ( map["runUID"] )
		self.origin <- ( map["origin"] )
		self.targetCollectionName <- ( map["targetCollectionName"] )
		self.creationDate <- ( map["creationDate"], ISO8601DateTransform() )
		self.action <- ( map["action"] )
		self.UIDS <- ( map["UIDS"] )
        self.enableSupervision()
        self.enableAutoCommit()
    }


    // MARK: NSSecureCoding

    required public init?(coder decoder: NSCoder) {
        super.init(coder: decoder)
        self.disableSupervision()
        self.disableAutoCommit()
		self.index=decoder.decodeIntegerForKey("index") 
		self.spaceUID=String(decoder.decodeObjectOfClass(NSString.self, forKey:"spaceUID") as NSString?)
		self.observationUID=String(decoder.decodeObjectOfClass(NSString.self, forKey:"observationUID") as NSString?)
		self.senderUID=String(decoder.decodeObjectOfClass(NSString.self, forKey:"senderUID") as NSString?)
		self.runUID=String(decoder.decodeObjectOfClass(NSString.self, forKey:"runUID") as NSString?)
		self.origin=String(decoder.decodeObjectOfClass(NSString.self, forKey:"origin") as NSString?)
		self.targetCollectionName=String(decoder.decodeObjectOfClass(NSString.self, forKey: "targetCollectionName")! as NSString)
		self.creationDate=decoder.decodeObjectOfClass(NSDate.self, forKey:"creationDate") as NSDate?
		self.action=String(decoder.decodeObjectOfClass(NSString.self, forKey: "action")! as NSString)
		self.UIDS=String(decoder.decodeObjectOfClass(NSString.self, forKey: "UIDS")! as NSString)

        self.enableSupervision()
        self.enableAutoCommit()
    }

    override public func encodeWithCoder(coder: NSCoder) {
        super.encodeWithCoder(coder)
		coder.encodeInteger(self.index,forKey:"index")
		if let spaceUID = self.spaceUID {
			coder.encodeObject(spaceUID,forKey:"spaceUID")
		}
		if let observationUID = self.observationUID {
			coder.encodeObject(observationUID,forKey:"observationUID")
		}
		if let senderUID = self.senderUID {
			coder.encodeObject(senderUID,forKey:"senderUID")
		}
		if let runUID = self.runUID {
			coder.encodeObject(runUID,forKey:"runUID")
		}
		if let origin = self.origin {
			coder.encodeObject(origin,forKey:"origin")
		}
		coder.encodeObject(self.targetCollectionName,forKey:"targetCollectionName")
		if let creationDate = self.creationDate {
			coder.encodeObject(creationDate,forKey:"creationDate")
		}
		coder.encodeObject(self.action,forKey:"action")
		coder.encodeObject(self.UIDS,forKey:"UIDS")
    }


    override public class func supportsSecureCoding() -> Bool{
        return true
    }


    required public init() {
        super.init()
    }

    // MARK: Identifiable

    override public class var collectionName:String{
        return "triggers"
    }

    override public var d_collectionName:String{
        return Trigger.collectionName
    }


}

